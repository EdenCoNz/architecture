# =============================================================================
# Docker Compose Staging Environment Configuration
# =============================================================================
# This file provides staging-specific overrides for the base docker-compose.yml
#
# ENVIRONMENT: staging
#
# Usage:
#   docker compose -f docker-compose.yml -f compose.staging.yml up -d
#   docker compose -f docker-compose.yml -f compose.staging.yml down
#   docker compose -f docker-compose.yml -f compose.staging.yml logs -f
#
# Or use the environment helper script:
#   ./docker-env.sh staging start
#   ./docker-env.sh staging stop
#   ./docker-env.sh staging logs
#
# Features:
#   - Production-like configuration with staging-specific settings
#   - Pre-built production images (not built from source)
#   - Moderate resource limits for cost optimization
#   - Enhanced logging for debugging
#   - No direct port exposure (only through reverse proxy)
#   - HTTPS ready with proper security settings
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Backend Service - Staging Configuration
  # ---------------------------------------------------------------------------
  backend:
    # Use production image from container registry
    # Image includes full registry path (e.g., ghcr.io/edenconz/backend:1.0.0)
    # BACKEND_IMAGE should be set with full registry path in .env file
    # Default uses REPOSITORY_OWNER variable set by GitHub Actions
    image: ${BACKEND_IMAGE:-${CONTAINER_REGISTRY:-ghcr.io}/${REPOSITORY_OWNER}/backend:${BACKEND_VERSION:-1.0.0}}

    # Pull images from registry (default behavior)
    # Images are pulled from container registry before starting
    pull_policy: always

    # No build configuration - images are pre-built in CI/CD and pulled from registry

    # Load staging environment variables from file
    env_file:
      - ./backend/.env.staging

    # Staging environment variables
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings.staging
      - DEBUG=False
      - LOG_LEVEL=INFO
      - ENVIRONMENT=staging

      # Security - Load from environment or .env file
      # This overrides the insecure default in docker-compose.yml
      - SECRET_KEY=${SECRET_KEY}

      # Database connection (use service name as host)
      - DB_HOST=db
      - DB_PORT=5432

      # Redis connection (use service name as host)
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1
      - CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/0

      # Security settings for HTTPS
      # SECURE_SSL_REDIRECT=False in staging to allow both HTTP and HTTPS for testing
      # Production should set this to True for security
      - SECURE_SSL_REDIRECT=False
      - SESSION_COOKIE_SECURE=True
      - CSRF_COOKIE_SECURE=True

      # Frontend runtime config for staging
      # :TODO
      - FRONTEND_API_URL=https://staging.edenco.online
      - FRONTEND_API_ENABLE_LOGGING=true
      - FRONTEND_APP_NAME=Application (Staging)
      - FRONTEND_APP_VERSION=${APP_VERSION:-1.0.0-staging}
      - FRONTEND_ENABLE_DEBUG=false
      - FRONTEND_ENABLE_ANALYTICS=false

    # No direct port exposure in staging - only through reverse proxy
    ports: []

    # Staging volumes - override base volumes completely (no source code bind mount)
    volumes: !override
      - backend_media:/app/media
      - backend_static:/app/staticfiles

    # Staging resource limits - moderate
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G

    # Always restart in staging
    restart: always

    # Optimized health check for staging
    # Longer start_period than production to account for lower resource allocation
    # Use 127.0.0.1 instead of localhost to force IPv4 (Django binds to 0.0.0.0 IPv4 by default)
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:8000/api/v1/health/"]
      interval: 45s
      timeout: 5s
      retries: 3
      start_period: 90s

    # Structured logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=backend"

  # ---------------------------------------------------------------------------
  # Frontend Service - Staging Configuration
  # ---------------------------------------------------------------------------
  frontend:
    # Use production image from container registry
    # Image includes full registry path (e.g., ghcr.io/edenconz/frontend:1.0.0)
    # FRONTEND_IMAGE should be set with full registry path in .env file
    # Default uses REPOSITORY_OWNER variable set by GitHub Actions
    image: ${FRONTEND_IMAGE:-${CONTAINER_REGISTRY:-ghcr.io}/${REPOSITORY_OWNER}/frontend:${FRONTEND_VERSION:-1.0.0}}

    # Pull images from registry (default behavior)
    # Images are pulled from container registry before starting
    pull_policy: always

    # No build configuration - images are pre-built in CI/CD and pulled from registry

    # Load staging environment variables from file
    env_file:
      - ./frontend/.env.staging

    # Staging environment variables
    environment:
      - NODE_ENV=production
      - ENVIRONMENT=staging

    # No direct port exposure in staging - only through reverse proxy
    ports: []

    # Staging volumes - no bind mounts
    volumes: []

    # Staging resource limits - moderate
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

    # Always restart in staging
    restart: always

    # Optimized health check for staging
    # Production image runs nginx on port 80 with /health endpoint
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/health"]
      interval: 45s
      timeout: 5s
      retries: 3
      start_period: 60s

    # Structured logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=frontend"

  # ---------------------------------------------------------------------------
  # Database Service - Staging Configuration
  # ---------------------------------------------------------------------------
  db:
    # Load staging environment variables
    environment:
      POSTGRES_DB: ${DB_NAME:-backend_staging_db}
      POSTGRES_USER: ${DB_USER:-backend_staging_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}  # Must be set in .env.staging
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=en_US.utf8"

      # PostgreSQL performance tuning for staging
      POSTGRES_SHARED_BUFFERS: ${POSTGRES_SHARED_BUFFERS:-256MB}
      POSTGRES_EFFECTIVE_CACHE_SIZE: ${POSTGRES_EFFECTIVE_CACHE_SIZE:-1GB}
      POSTGRES_MAX_CONNECTIONS: ${POSTGRES_MAX_CONNECTIONS:-100}

    # No direct port exposure in staging
    ports: []

    # Staging resource limits
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M

    # Always restart in staging
    restart: always

    # Optimized health check for staging
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-backend_staging_user} -d ${DB_NAME:-backend_staging_db}"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

    # Enhanced logging
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=database"

  # ---------------------------------------------------------------------------
  # Redis Service - Staging Configuration
  # ---------------------------------------------------------------------------
  redis:
    # Redis with password for security
    # Using array syntax to properly handle special characters in REDIS_PASSWORD
    command:
      - redis-server
      - --requirepass
      - ${REDIS_PASSWORD}
      - --appendonly
      - "yes"
      - --maxmemory
      - ${REDIS_MAXMEMORY:-512mb}
      - --maxmemory-policy
      - allkeys-lru
      - --save
      - "900"
      - "1"
      - --save
      - "300"
      - "10"
      - --save
      - "60"
      - "10000"

    # No direct port exposure in staging
    ports: []

    # Override health check to use password authentication
    healthcheck:
      test: ["CMD", "redis-cli", "--pass", "${REDIS_PASSWORD}", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s

    # Staging resource limits
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M

    # Always restart in staging
    restart: always

    # Enhanced logging
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=redis"

  # ---------------------------------------------------------------------------
  # Proxy Service - Staging Configuration
  # ---------------------------------------------------------------------------
  proxy:
    # Use nginx configuration (SSL/TLS configuration pending)
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      # SSL mount pending - add when certificates are configured
      # - ./nginx/ssl:/etc/nginx/ssl:ro
      - proxy_logs:/var/log/nginx

    # Expose HTTP and HTTPS ports
    ports:
      - "80:80"
      - "443:443"

    # Staging resource limits
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M

    # Always restart in staging
    restart: always

    # Optimized health check for staging
    # Use 127.0.0.1 to force IPv4
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s

    # Enhanced logging
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=proxy"

  # ---------------------------------------------------------------------------
  # Celery Worker Service - Staging Configuration
  # ---------------------------------------------------------------------------
  celery:
    # Use production backend image from registry (same version as backend service)
    # Default uses REPOSITORY_OWNER variable set by GitHub Actions
    image: ${BACKEND_IMAGE:-${CONTAINER_REGISTRY:-ghcr.io}/${REPOSITORY_OWNER}/backend:${BACKEND_VERSION:-1.0.0}}

    # Pull images from registry (default behavior)
    pull_policy: always

    # Load staging environment variables
    env_file:
      - ./backend/.env.staging

    # Staging environment
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings.staging
      - ENVIRONMENT=staging
      - DB_HOST=db
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1
      - CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/0

    # Celery command with staging concurrency
    command: celery -A config worker -l info --concurrency=${CELERY_WORKER_CONCURRENCY:-4}

    # Staging resource limits
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

    # Always restart in staging
    restart: always

    # Remove profile - always run in staging
    profiles: []

    # Enhanced logging
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
        labels: "environment=staging,service=celery"

# =============================================================================
# Staging Volumes
# =============================================================================
volumes:
  postgres_data:
    name: app-staging-postgres-data
  redis_data:
    name: app-staging-redis-data
  backend_media:
    name: app-staging-backend-media
  backend_static:
    name: app-staging-backend-static
  proxy_logs:
    name: app-staging-proxy-logs

# =============================================================================
# Staging Network
# =============================================================================
networks:
  app-network:
    name: app-staging-network
    driver: bridge
