name: Unified CI/CD Pipeline

# ==============================================================================
# Unified CI/CD Pipeline - Single Workflow for Complete Application Stack
# ==============================================================================
#
# Pipeline Stages:
#   1. Build and Test - Build complete stack, run all tests except E2E
#   2. Deploy to Staging - Deploy build to staging server
#   3. E2E Testing - Run E2E tests against staging environment
#   4. Deploy to Production - Deploy to production after E2E validation
#
# Features:
#   - Single docker-compose build for entire application
#   - Sequential deployment with quality gates
#   - E2E validation before production deployment
#   - Automatic failure detection and issue creation
#   - Container cleanup protocol before testing
#
# ==============================================================================

on:
  push:
    branches: [main, 'feature/**']
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose.yml'
      - 'compose.*.yml'
      - '.github/workflows/unified-ci-cd.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip backend and frontend tests (for deployment testing only)'
        required: false
        type: boolean
        default: false

# Explicit permissions (least privilege)
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  security-events: write
  packages: write

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: BUILD AND TEST
  # ============================================================================
  # Build the complete Docker Compose stack and run all tests except E2E
  # This ensures the application builds correctly and passes all unit/integration tests
  # ============================================================================

  build-and-test:
    name: Build and Test Complete Stack
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Sanitize Branch Name for Docker Tags
      # ----------------------------------------------------------------
      # Docker image tags cannot contain forward slashes, which are present
      # in branch names like "292/merge" from GitHub pull requests.
      # This step converts "/" to "-" for safe Docker tag usage.
      # ----------------------------------------------------------------
      - name: Sanitize branch name for Docker tags
        id: sanitized_ref
        run: |
          # Replace forward slashes with hyphens for Docker tag compatibility
          SANITIZED_REF=$(echo '${{ github.ref_name }}' | sed 's/\//-/g')
          echo "ref=$SANITIZED_REF" >> $GITHUB_OUTPUT
          echo "Sanitized branch name: $GITHUB_REF_NAME -> $SANITIZED_REF" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Container Registry Configuration
      # ----------------------------------------------------------------
      # Default: GitHub Container Registry (ghcr.io)
      # Can be overridden via CONTAINER_REGISTRY environment variable
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REGISTRY_PATH="${REGISTRY}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Registry Path**: ${REGISTRY_PATH}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Authenticate to Container Registry (for pushing images)
      # ----------------------------------------------------------------
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ----------------------------------------------------------------
      # Container Cleanup Protocol (MANDATORY)
      # ----------------------------------------------------------------
      - name: Clean up existing containers
        run: |
          echo "## Container Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Stop and remove any existing containers
          docker compose down -v --remove-orphans 2>/dev/null || true

          # Verify clean state
          RUNNING_CONTAINERS=$(docker ps -q | wc -l)
          echo "Running containers after cleanup: $RUNNING_CONTAINERS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build Complete Application Stack
      # ----------------------------------------------------------------
      # Uses GitHub Actions cache backend for efficient layer caching
      # Multi-level cache fallback strategy:
      # 1. Version+branch cache (version-specific current work)
      # 2. Version+main cache (version-specific shared layers)
      # 3. Branch cache (cross-version fallback)
      # 4. Main branch cache (cross-version shared layers)
      # 5. General cache (last resort fallback)
      # ----------------------------------------------------------------
      - name: Extract backend version from config/__init__.py
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build backend development container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            backend-dev:${{ steps.backend_version.outputs.version }}
            backend-dev:latest
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}

      - name: Extract frontend version from package.json
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "Extracted frontend version: $FRONTEND_VERSION"

      - name: Build frontend development container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            frontend-dev:${{ steps.frontend_version.outputs.version }}
            frontend-dev:latest
          cache-from: |
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}

      - name: Build complete application stack summary
        run: |
          echo "## Building Complete Application Stack" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Complete stack built successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show image sizes
          echo "### Container Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "(backend-dev|frontend-dev|SIZE)"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Test Skip Notice
      # ----------------------------------------------------------------
      - name: Tests skipped notice
        if: ${{ inputs.skip_tests }}
        run: |
          echo "## ⚠️ Tests Skipped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Backend and frontend tests were skipped as requested." >> $GITHUB_STEP_SUMMARY
          echo "**This should only be used for deployment testing purposes.**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Backend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run backend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Backend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Start dependencies
          docker compose up -d db redis

          # Wait for PostgreSQL to be ready with enhanced validation
          echo "Waiting for PostgreSQL to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T db pg_isready -U postgres; do sleep 2; done'

          # Verify database can execute queries (not just accept connections)
          echo "Verifying database can execute queries..." >> $GITHUB_STEP_SUMMARY
          timeout 30 bash -c 'until docker compose exec -T db psql -U postgres -c "SELECT 1" > /dev/null 2>&1; do sleep 2; done'

          # Additional stabilization period for connection pooling initialization
          echo "Database stabilization period..." >> $GITHUB_STEP_SUMMARY
          sleep 5

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T redis redis-cli ping | grep -q PONG; do sleep 2; done'

          # Verify services are healthy before running tests
          echo "Verifying all services are healthy..." >> $GITHUB_STEP_SUMMARY
          docker compose ps
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run backend tests
          docker compose run --rm \
            -e DJANGO_SETTINGS_MODULE=config.settings.testing \
            -e SECRET_KEY=test-secret-key \
            -e USE_POSTGRES_FOR_TESTS=true \
            -e DB_HOST=db \
            -e DB_PORT=5432 \
            -e DB_NAME=backend_db \
            -e DB_USER=postgres \
            -e DB_PASSWORD=postgres \
            backend \
            pytest --cov=apps \
              --cov-report=xml \
              --cov-report=term-missing \
              --junitxml=pytest-report.xml \
              -n auto

          echo "✅ Backend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Frontend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run frontend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Frontend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run frontend tests
          docker compose run --rm frontend npm run test:run

          echo "✅ Frontend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Linting and Type Checking
      # ----------------------------------------------------------------
      - name: Run linting and type checks
        run: |
          echo "## Code Quality Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Backend linting
          docker compose run --rm backend bash -c "black --check . && isort --check-only . && flake8"
          echo "✅ Backend linting passed" >> $GITHUB_STEP_SUMMARY

          # Frontend linting
          docker compose run --rm frontend npm run lint
          echo "✅ Frontend linting passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build and Push Production Images to Registry
      # ----------------------------------------------------------------
      # After tests pass, build production-optimized images and push to registry
      # These images use the production Dockerfile target with optimizations
      # Images are pushed to registry for direct pulling by deployment servers
      # ----------------------------------------------------------------
      - name: Build and push backend production container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: production
          push: true
          no-cache: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/backend:latest
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.sanitized_ref.outputs.ref }}
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.backend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push frontend production container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/frontend:latest
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.sanitized_ref.outputs.ref }}
          build-args: |
            VERSION=${{ steps.frontend_version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: |
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.frontend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build production images summary
        run: |
          echo "## Production Images Published to Registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Production images built and pushed to registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show published image details
          echo "### Published Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Backend:  ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}"
          echo "Frontend: ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show all tags published
          echo "### Published Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Cleanup
      # ----------------------------------------------------------------
      - name: Cleanup after build
        if: always()
        run: |
          docker compose down -v --remove-orphans

  # ============================================================================
  # STAGE 2: DEPLOY TO STAGING
  # ============================================================================
  # Deploy the successfully built and tested application to staging environment
  # Only runs if build-and-test succeeds
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    needs: [build-and-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy from main branch (via push or manual trigger)
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment:
      name: Staging
      url: https://staging.edenco.online

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Staging Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Staging Server
      # ----------------------------------------------------------------
      - name: Deploy to staging server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-staging"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Staging)
          DJANGO_SETTINGS_MODULE=config.settings.staging
          DEBUG=False
          LOG_LEVEL=INFO
          ENVIRONMENT=staging

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/backend/.env.staging << 'ENV_EOF'
          # Backend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Staging)
          NODE_ENV=production
          ENVIRONMENT=staging
          ENV_EOF

          # Create frontend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/frontend/.env.staging << 'ENV_EOF'
          # Frontend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Staging)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Clean Cache Volumes
          # ================================================================
          echo "#### Step 1: Cleaning cache volumes" >> $GITHUB_STEP_SUMMARY
          echo "Removing stale cache volumes to prevent serving outdated content..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            cd ${DEPLOY_DIR}

            echo '=== Cache Volume Cleanup ==='
            echo 'Removing cache-only volumes to prevent stale content:'
            echo ''

            # Remove nginx cache volumes (static and media file caches)
            # These can serve stale content after deployments if not cleared
            docker volume rm app-staging_proxy_cache_static 2>/dev/null && echo '✅ Removed proxy_cache_static' || echo 'ℹ️  proxy_cache_static not found (first deployment or already clean)'
            docker volume rm app-staging_proxy_cache_media 2>/dev/null && echo '✅ Removed proxy_cache_media' || echo 'ℹ️  proxy_cache_media not found (first deployment or already clean)'

            # Remove Redis data volume to flush all cache entries
            # This prevents old application state from persisting across deployments
            docker volume rm app-staging_redis_data 2>/dev/null && echo '✅ Removed redis_data (cache will be rebuilt)' || echo 'ℹ️  redis_data not found (first deployment or already clean)'

            echo ''
            echo '=== Preserved Data Volumes ==='
            echo 'The following volumes are PRESERVED (user data):'
            echo '  - postgres_data (database - contains user data)'
            echo '  - backend_media (user uploads)'
            echo '  - backend_static (collected static files - will be regenerated)'
            echo '  - proxy_logs (nginx access/error logs for debugging)'
            echo ''
          " | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Cache volumes cleaned successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Stop Existing Containers
          # ================================================================
          echo "#### Step 2: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.staging.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Create Deployment directories
          # ================================================================
          echo "#### Step 3: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "✅ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Transfer Configuration Files
          # ================================================================
          echo "#### Step 4: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            # Ensure deployment directory ownership is correct
            sudo chown -R ${SERVER_USER}:${SERVER_USER} ${DEPLOY_DIR} 2>/dev/null || true

            # Remove any read-only flags and ensure write permissions
            chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true

            # Wait for file locks to be released after container shutdown
            sleep 5

            # Verify directories are writable
            if [ ! -w \"${DEPLOY_DIR}/nginx\" ]; then
              echo \"Warning: ${DEPLOY_DIR}/nginx is still not writable after permission fix\"
              ls -ld ${DEPLOY_DIR}/nginx
            fi
          "

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.staging.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.production.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.production.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "Transferring deployment script..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            .github/scripts/deploy-staging.sh \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/deploy-staging.sh

          echo "✅ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 5: Execute Deployment Script on Server
          # ================================================================
          echo "#### Step 5: Executing deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Running deployment script with health monitoring..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Execute deployment script on server
          # Use single quotes to prevent variable expansion on the client side
          # and properly escape variables for the remote shell
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && \
            REGISTRY='${REGISTRY}' \
            GITHUB_ACTOR='${GITHUB_ACTOR}' \
            GITHUB_TOKEN='${GITHUB_TOKEN}' \
            REDIS_PASSWORD='${REDIS_PASSWORD//\'/\'\\\'\'}' \
            bash deploy-staging.sh"

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "✅ **Staging deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Staging deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify staging deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for staging environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "✅ Staging environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "⚠️ Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "Response: ${BODY}" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Staging environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

  # ============================================================================
  # DIAGNOSTIC COLLECTION - STAGING
  # ============================================================================
  # Collect comprehensive diagnostics if staging deployment fails
  # ============================================================================

  collect-staging-diagnostics:
    name: Collect Staging Diagnostics
    needs: [deploy-staging]
    if: failure() && needs.deploy-staging.result == 'failure'
    uses: ./.github/workflows/collect-deployment-diagnostics.yml
    with:
      environment: Staging
      compose_file: compose.staging.yml
    secrets:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  # ============================================================================
  # STAGE 3: E2E TESTING
  # ============================================================================
  # Run end-to-end tests against the staging environment
  # Only runs if deploy-staging succeeds
  # ============================================================================

  e2e-testing:
    name: E2E Tests Against Staging
    needs: [deploy-staging]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    environment:
      name: Staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Connect to Staging via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      # ----------------------------------------------------------------
      # Run E2E Tests Against Staging
      # ----------------------------------------------------------------
      - name: Run E2E tests against staging
        id: e2e_tests
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## E2E Testing Against Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create test configuration pointing to staging
          cat > .env.e2e << EOF
          PLAYWRIGHT_BASE_URL=http://${SERVER_HOST}
          PLAYWRIGHT_HEADLESS=true
          CI=true
          EOF

          # Build test runner
          docker compose -f compose.test.yml build test-runner

          # Run E2E tests
          mkdir -p testing/reports

          docker compose -f compose.test.yml run --rm \
            --env-file .env.e2e \
            test-runner \
            bash -c "cd /app/testing/e2e && npx playwright test --reporter=html,json,list" \
            || echo "e2e_failed=true" >> $GITHUB_OUTPUT

          # Generate summary
          if [ "${{ steps.e2e_tests.outputs.e2e_failed }}" != "true" ]; then
            echo "✅ E2E tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ E2E tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ github.sha }}
          path: |
            testing/e2e/playwright-report/
            testing/e2e/test-results/
          retention-days: 30
          if-no-files-found: warn

      - name: Fail if E2E tests failed
        if: steps.e2e_tests.outputs.e2e_failed == 'true'
        run: |
          echo "❌ E2E tests failed - blocking production deployment"
          exit 1

  # ============================================================================
  # STAGE 4: DEPLOY TO PRODUCTION
  # ============================================================================
  # Deploy to production environment
  # ONLY runs if all previous stages succeed (build, staging deploy, E2E tests)
  # ============================================================================

  deploy-production:
    name: Deploy to Production
    needs: [build-and-test, deploy-staging, e2e-testing]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy to production from main branch after all stages pass (via push or manual trigger)
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment:
      name: Production
      url: https://yourdomain.com

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Production Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Production Server
      # ----------------------------------------------------------------
      - name: Deploy to production server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-production"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Production)
          DJANGO_SETTINGS_MODULE=config.settings.production
          DEBUG=False
          LOG_LEVEL=WARNING
          ENVIRONMENT=production

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/backend/.env.production << 'ENV_EOF'
          # Backend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Production)
          NODE_ENV=production
          ENVIRONMENT=production
          ENV_EOF

          # Create frontend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/frontend/.env.production << 'ENV_EOF'
          # Frontend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Production)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Clean Cache Volumes
          # ================================================================
          echo "#### Step 1: Cleaning cache volumes" >> $GITHUB_STEP_SUMMARY
          echo "Removing stale cache volumes to prevent serving outdated content..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            cd ${DEPLOY_DIR}

            echo '=== Cache Volume Cleanup ==='
            echo 'Removing cache-only volumes to prevent stale content:'
            echo ''

            # Remove nginx cache volumes (static and media file caches)
            # These can serve stale content after deployments if not cleared
            docker volume rm app-production_proxy_cache_static 2>/dev/null && echo '✅ Removed proxy_cache_static' || echo 'ℹ️  proxy_cache_static not found (first deployment or already clean)'
            docker volume rm app-production_proxy_cache_media 2>/dev/null && echo '✅ Removed proxy_cache_media' || echo 'ℹ️  proxy_cache_media not found (first deployment or already clean)'

            # Remove Redis data volume to flush all cache entries
            # This prevents old application state from persisting across deployments
            docker volume rm app-production_redis_data 2>/dev/null && echo '✅ Removed redis_data (cache will be rebuilt)' || echo 'ℹ️  redis_data not found (first deployment or already clean)'

            echo ''
            echo '=== Preserved Data Volumes ==='
            echo 'The following volumes are PRESERVED (user data):'
            echo '  - postgres_data (database - contains user data)'
            echo '  - backend_media (user uploads)'
            echo '  - backend_static (collected static files - will be regenerated)'
            echo '  - proxy_logs (nginx access/error logs for debugging)'
            echo ''
          " | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Cache volumes cleaned successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Stop Existing Containers
          # ================================================================
          echo "#### Step 2: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.production.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Create Deployment Directories
          # ================================================================
          echo "#### Step 3: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "✅ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Transfer Configuration Files
          # ================================================================
          echo "#### Step 4: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            # Ensure deployment directory ownership is correct
            sudo chown -R ${SERVER_USER}:${SERVER_USER} ${DEPLOY_DIR} 2>/dev/null || true

            # Remove any read-only flags and ensure write permissions
            chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true

            # Wait for file locks to be released after container shutdown
            sleep 5

            # Verify directories are writable
            if [ ! -w \"${DEPLOY_DIR}/nginx\" ]; then
              echo \"Warning: ${DEPLOY_DIR}/nginx is still not writable after permission fix\"
              ls -ld ${DEPLOY_DIR}/nginx
            fi
          "

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.production.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.production.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.production.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "Transferring deployment script..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            .github/scripts/deploy-production.sh \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/deploy-production.sh

          echo "✅ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 5: Execute Deployment Script on Server
          # ================================================================
          echo "#### Step 5: Executing deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Running deployment script with health monitoring..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Execute deployment script on server
          # Use single quotes to prevent variable expansion on the client side
          # and properly escape variables for the remote shell
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && \
            REGISTRY='${REGISTRY}' \
            GITHUB_ACTOR='${GITHUB_ACTOR}' \
            GITHUB_TOKEN='${GITHUB_TOKEN}' \
            REDIS_PASSWORD='${REDIS_PASSWORD//\'/\'\\\'\'}' \
            bash deploy-production.sh"

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "✅ **Production deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Production deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify production deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for production environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "✅ Production environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "⚠️ Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "Response: ${BODY}" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Production environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Production deployment summary
        if: success()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Application successfully deployed to production**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # DIAGNOSTIC COLLECTION - PRODUCTION
  # ============================================================================
  # Collect comprehensive diagnostics if production deployment fails
  # ============================================================================

  collect-production-diagnostics:
    name: Collect Production Diagnostics
    needs: [deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'
    uses: ./.github/workflows/collect-deployment-diagnostics.yml
    with:
      environment: Production
      compose_file: compose.production.yml
    secrets:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  # ============================================================================
  # FAILURE DETECTION AND ISSUE CREATION
  # ============================================================================
  # Automatically detect workflow failures and create GitHub issues
  # Runs if any previous job fails
  # ============================================================================

  detect-workflow-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure() || cancelled()
    needs: [build-and-test, deploy-staging, e2e-testing, deploy-production]
    permissions:
      issues: write
      contents: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create failure tracking issue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "## Workflow Failure Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine which stage failed
          FAILED_STAGE="Unknown"
          if [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            FAILED_STAGE="Build and Test"
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Staging"
          elif [ "${{ needs.e2e-testing.result }}" = "failure" ]; then
            FAILED_STAGE="E2E Testing"
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Production"
          fi

          # Create issue title
          ISSUE_TITLE="CI/CD Pipeline Failed: $FAILED_STAGE - Run #${{ github.run_number }}"

          # Create issue body
          cat > /tmp/issue_body.md << EOF
          # CI/CD Pipeline Failure

          ## Failure Information

          - **Failed Stage**: $FAILED_STAGE
          - **Workflow**: Unified CI/CD Pipeline
          - **Run Number**: ${{ github.run_number }}
          - **Branch**: ${{ github.ref_name }}
          - **Commit**: ${{ github.sha }}
          - **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## Pipeline Status

          - Build and Test: ${{ needs.build-and-test.result }}
          - Deploy to Staging: ${{ needs.deploy-staging.result }}
          - E2E Testing: ${{ needs.e2e-testing.result }}
          - Deploy to Production: ${{ needs.deploy-production.result }}

          ## Next Steps

          1. Review the workflow logs at the run URL above
          2. Identify the root cause of the failure
          3. Fix the issue and commit with "Fix issue #N" to auto-close this issue

          ---

          Created by: Unified CI/CD Pipeline
          EOF

          # Create the issue with available labels
          # Note: Only use labels that exist in the repository
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md \
            --label "bug" || gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md)

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')

          echo "✅ Created issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
