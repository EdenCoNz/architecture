name: Unified CI/CD Pipeline

# ==============================================================================
# Unified CI/CD Pipeline - Single Workflow for Complete Application Stack
# ==============================================================================
#
# Pipeline Stages:
#   1. Build and Test - Build complete stack, run all tests except E2E
#   2. Deploy to Staging - Deploy build to staging server
#   3. E2E Testing - Run E2E tests against staging environment
#   4. Deploy to Production - Deploy to production after E2E validation
#
# Features:
#   - Single docker-compose build for entire application
#   - Sequential deployment with quality gates
#   - E2E validation before production deployment
#   - Automatic failure detection and issue creation
#   - Container cleanup protocol before testing
#
# ==============================================================================

on:
  push:
    branches: [main, 'feature/**']
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose.yml'
      - 'compose.*.yml'
      - '.github/workflows/unified-ci-cd.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip backend and frontend tests (for deployment testing only)'
        required: false
        type: boolean
        default: false

# Explicit permissions (least privilege)
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  security-events: write
  packages: write

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: BUILD AND TEST
  # ============================================================================
  # Build the complete Docker Compose stack and run all tests except E2E
  # This ensures the application builds correctly and passes all unit/integration tests
  # ============================================================================

  build-and-test:
    name: Build and Test Complete Stack
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Container Registry Configuration
      # ----------------------------------------------------------------
      # Default: GitHub Container Registry (ghcr.io)
      # Can be overridden via CONTAINER_REGISTRY environment variable
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REGISTRY_PATH="${REGISTRY}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Registry Path**: ${REGISTRY_PATH}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Authenticate to Container Registry (for pushing images)
      # ----------------------------------------------------------------
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ----------------------------------------------------------------
      # Container Cleanup Protocol (MANDATORY)
      # ----------------------------------------------------------------
      - name: Clean up existing containers
        run: |
          echo "## Container Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Stop and remove any existing containers
          docker compose down -v --remove-orphans 2>/dev/null || true

          # Verify clean state
          RUNNING_CONTAINERS=$(docker ps -q | wc -l)
          echo "Running containers after cleanup: $RUNNING_CONTAINERS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build Complete Application Stack
      # ----------------------------------------------------------------
      # Uses GitHub Actions cache backend for efficient layer caching
      # Multi-level cache fallback strategy:
      # 1. Version+branch cache (version-specific current work)
      # 2. Version+main cache (version-specific shared layers)
      # 3. Branch cache (cross-version fallback)
      # 4. Main branch cache (cross-version shared layers)
      # 5. General cache (last resort fallback)
      # ----------------------------------------------------------------
      - name: Extract backend version from config/__init__.py
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build backend development container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            backend-dev:${{ steps.backend_version.outputs.version }}
            backend-dev:latest
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}

      - name: Extract frontend version from package.json
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build frontend development container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            frontend-dev:${{ steps.frontend_version.outputs.version }}
            frontend-dev:latest
          cache-from: |
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}

      - name: Build complete application stack summary
        run: |
          echo "## Building Complete Application Stack" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Complete stack built successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show image sizes
          echo "### Container Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "(backend-dev|frontend-dev|SIZE)"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Test Skip Notice
      # ----------------------------------------------------------------
      - name: Tests skipped notice
        if: ${{ inputs.skip_tests }}
        run: |
          echo "## ‚ö†Ô∏è Tests Skipped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Backend and frontend tests were skipped as requested." >> $GITHUB_STEP_SUMMARY
          echo "**This should only be used for deployment testing purposes.**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Backend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run backend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Backend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Start dependencies
          docker compose up -d db redis

          # Wait for PostgreSQL to be ready with enhanced validation
          echo "Waiting for PostgreSQL to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T db pg_isready -U postgres; do sleep 2; done'

          # Verify database can execute queries (not just accept connections)
          echo "Verifying database can execute queries..." >> $GITHUB_STEP_SUMMARY
          timeout 30 bash -c 'until docker compose exec -T db psql -U postgres -c "SELECT 1" > /dev/null 2>&1; do sleep 2; done'

          # Additional stabilization period for connection pooling initialization
          echo "Database stabilization period..." >> $GITHUB_STEP_SUMMARY
          sleep 5

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T redis redis-cli ping | grep -q PONG; do sleep 2; done'

          # Verify services are healthy before running tests
          echo "Verifying all services are healthy..." >> $GITHUB_STEP_SUMMARY
          docker compose ps
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run backend tests
          docker compose run --rm \
            -e DJANGO_SETTINGS_MODULE=config.settings.testing \
            -e SECRET_KEY=test-secret-key \
            -e USE_POSTGRES_FOR_TESTS=true \
            -e DB_HOST=db \
            -e DB_PORT=5432 \
            -e DB_NAME=backend_db \
            -e DB_USER=postgres \
            -e DB_PASSWORD=postgres \
            backend \
            pytest --cov=apps \
              --cov-report=xml \
              --cov-report=term-missing \
              --junitxml=pytest-report.xml \
              -n auto

          echo "‚úÖ Backend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Frontend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run frontend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Frontend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run frontend tests
          docker compose run --rm frontend npm run test:run

          echo "‚úÖ Frontend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Linting and Type Checking
      # ----------------------------------------------------------------
      - name: Run linting and type checks
        run: |
          echo "## Code Quality Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Backend linting
          docker compose run --rm backend bash -c "black --check . && isort --check-only . && flake8"
          echo "‚úÖ Backend linting passed" >> $GITHUB_STEP_SUMMARY

          # Frontend linting
          docker compose run --rm frontend npm run lint
          echo "‚úÖ Frontend linting passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build and Push Production Images to Registry
      # ----------------------------------------------------------------
      # After tests pass, build production-optimized images and push to registry
      # These images use the production Dockerfile target with optimizations
      # Images are pushed to registry for direct pulling by deployment servers
      # ----------------------------------------------------------------
      - name: Build and push backend production container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: production
          push: true
          no-cache: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/backend:latest
            ${{ steps.registry.outputs.registry_path }}/backend:${{ github.ref_name }}
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.backend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push frontend production container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/frontend:latest
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ github.ref_name }}
          build-args: |
            VERSION=${{ steps.frontend_version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: |
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.frontend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build production images summary
        run: |
          echo "## Production Images Published to Registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Production images built and pushed to registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show published image details
          echo "### Published Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Backend:  ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}"
          echo "Frontend: ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show all tags published
          echo "### Published Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Cleanup
      # ----------------------------------------------------------------
      - name: Cleanup after build
        if: always()
        run: |
          docker compose down -v --remove-orphans

  # ============================================================================
  # STAGE 2: DEPLOY TO STAGING
  # ============================================================================
  # Deploy the successfully built and tested application to staging environment
  # Only runs if build-and-test succeeds
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    needs: [build-and-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy from main branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: Staging
      url: https://staging.edenco.online

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Staging Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Staging Server
      # ----------------------------------------------------------------
      - name: Deploy to staging server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-staging"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Staging)
          DJANGO_SETTINGS_MODULE=config.settings.staging
          DEBUG=False
          LOG_LEVEL=INFO
          ENVIRONMENT=staging

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/backend/.env.staging << 'ENV_EOF'
          # Backend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Staging)
          NODE_ENV=production
          ENVIRONMENT=staging
          ENV_EOF

          # Create frontend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/frontend/.env.staging << 'ENV_EOF'
          # Frontend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Staging)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Stop Existing Containers
          # ================================================================
          echo "#### Step 1: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.staging.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Create Deployment Directories
          # ================================================================
          echo "#### Step 2: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "‚úÖ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Transfer Configuration Files
          # ================================================================
          echo "#### Step 3: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true && sleep 2"

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.staging.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "‚úÖ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Deploy Containers on Server
          # ================================================================
          echo "#### Step 4: Starting deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Connecting to server to pull images and start containers..." >> $GITHUB_STEP_SUMMARY
          echo "This step includes real-time health monitoring and will show detailed logs if any issues occur." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Deploy on staging server with registry authentication
          # Use -tt to force pseudo-terminal allocation for better output visibility
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << 'EOF'
            set -e
            cd /home/$SERVER_USER/deployments/app-staging

            echo ""
            echo "==================================================================="
            echo "STAGING DEPLOYMENT - STARTING"
            echo "==================================================================="
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S %Z')"
            echo "Deploy Directory: $(pwd)"
            echo "==================================================================="
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 1: Stopping Existing Containers"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.staging.yml down --remove-orphans || true
            echo "‚úÖ Existing containers stopped"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 2: Authenticating to Container Registry"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Registry: ${REGISTRY}"
            echo "User: ${GITHUB_ACTOR}"
            echo "${GITHUB_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_ACTOR} --password-stdin
            echo "‚úÖ Successfully authenticated to registry"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 3: Pulling Latest Images from Registry"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.staging.yml config | grep "image:" | sed 's/^ *//' || true
            echo ""
            docker compose -f docker-compose.yml -f compose.staging.yml pull
            echo "‚úÖ Images pulled successfully"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 4: Starting Services"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.staging.yml up -d --force-recreate --pull always
            echo "‚úÖ Services started - beginning health monitoring"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 5: MONITORING CONTAINER HEALTH"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""

            # Give services a moment to initialize
            sleep 3

            MAX_WAIT=120  # 2 minutes max wait
            ELAPSED=0
            CHECK_INTERVAL=5
            PREVIOUS_UNHEALTHY=""

            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
              echo "-------------------------------------------------------------------"
              echo "Health Check (\${ELAPSED}s / \${MAX_WAIT}s elapsed)"
              echo "-------------------------------------------------------------------"

              # Get detailed health status of all services with health checks
              HEALTH_STATUS=\$(docker compose -f docker-compose.yml -f compose.staging.yml ps --format json | \\
                jq -r 'select(.Health != "") | "\\(.Service):\\(.Health)"' 2>/dev/null || true)

              if [ -z "\$HEALTH_STATUS" ]; then
                echo "‚ö†Ô∏è No health status available yet - services still initializing..."
              else
                echo "Container Health Status:"
                echo "\$HEALTH_STATUS" | while IFS=: read -r service health; do
                  case "\$health" in
                    "healthy")
                      echo "  ‚úÖ \$service: healthy"
                      ;;
                    "starting")
                      echo "  üîÑ \$service: starting (health check in progress)"
                      ;;
                    "unhealthy")
                      echo "  ‚ùå \$service: UNHEALTHY"
                      ;;
                    *)
                      echo "  ‚ö†Ô∏è  \$service: \$health"
                      ;;
                  esac
                done
              fi

              # Get list of unhealthy services
              UNHEALTHY=\$(docker compose -f docker-compose.yml -f compose.staging.yml ps --format json | \\
                jq -r 'select(.Health != "" and .Health != "healthy" and .Health != "starting") | .Service' 2>/dev/null || true)

              # Check if all services are healthy
              STARTING=\$(docker compose -f docker-compose.yml -f compose.staging.yml ps --format json | \\
                jq -r 'select(.Health == "starting") | .Service' 2>/dev/null || true)

              if [ -z "\$UNHEALTHY" ] && [ -z "\$STARTING" ]; then
                echo ""
                echo "==================================================================="
                echo "‚úÖ ALL SERVICES ARE HEALTHY!"
                echo "==================================================================="
                echo ""
                docker compose -f docker-compose.yml -f compose.staging.yml ps
                exit 0
              fi

              # Show logs for newly unhealthy services
              if [ -n "\$UNHEALTHY" ]; then
                echo ""
                echo "üìã Displaying logs for unhealthy containers:"
                echo ""

                for service in \$UNHEALTHY; do
                  # Only show logs if this is a newly unhealthy service
                  if ! echo "\$PREVIOUS_UNHEALTHY" | grep -q "\$service"; then
                    echo ">>> NEW UNHEALTHY SERVICE DETECTED: \$service <<<"
                  fi

                  echo "--- \$service logs (last 30 lines) ---"
                  docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=30 "\$service" 2>&1 || echo "Failed to retrieve logs for \$service"
                  echo ""

                  # Show detailed container inspection for health check failures
                  echo "--- \$service health check details ---"
                  CONTAINER_NAME=\$(docker compose -f docker-compose.yml -f compose.staging.yml ps -q "\$service" 2>/dev/null)
                  if [ -n "\$CONTAINER_NAME" ]; then
                    docker inspect "\$CONTAINER_NAME" | jq -r '.[0].State.Health | "Health Status: " + .Status + "\nFailing Streak: " + (.FailingStreak|tostring) + "\nLast Check Output: " + (if .Log then .Log[0].Output else "No logs" end)' 2>&1 || echo "Failed to inspect container \$service"
                  fi
                  echo ""
                done

                PREVIOUS_UNHEALTHY="\$UNHEALTHY"
              fi

              # Show which services we're still waiting for
              if [ -n "\$STARTING" ]; then
                echo "‚è≥ Services still starting: \$STARTING"
              fi
              if [ -n "\$UNHEALTHY" ]; then
                echo "‚ùå Unhealthy services: \$UNHEALTHY"
              fi

              sleep \$CHECK_INTERVAL
              ELAPSED=\$((\$ELAPSED + \$CHECK_INTERVAL))
              echo ""
            done

            echo "==================================================================="
            echo "‚ùå TIMEOUT - SERVICES FAILED TO BECOME HEALTHY"
            echo "==================================================================="
            echo ""
            echo "Final service status:"
            docker compose -f docker-compose.yml -f compose.staging.yml ps
            echo ""

            echo "==================================================================="
            echo "FINAL LOG DUMP - ALL SERVICES"
            echo "==================================================================="
            echo ""

            for service in proxy backend frontend db redis; do
              echo "--- \$service logs (last 200 lines) ---"
              docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=200 "\$service" 2>&1 || echo "Service \$service not found"
              echo ""
            done

            exit 1
          EOF

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ **Staging deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Staging deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify staging deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for staging environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "‚úÖ Staging environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "‚ö†Ô∏è Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "Response: ${BODY}" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ùå Staging environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Collect deployment logs on failure
        if: steps.deploy.outcome == 'failure'
        continue-on-error: true
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Deployment Failed - Diagnostic Logs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment to staging failed. Collecting diagnostic information..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # SSH to server and collect logs from failed deployment
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << 'EOF'
            cd /home/${SERVER_USER}/deployments/app-staging

            echo "### Container Status"
            docker compose -f docker-compose.yml -f compose.staging.yml ps

            echo ""
            echo "### System Resources"
            echo "#### Disk Space"
            df -h | grep -E '(Filesystem|/dev/)' || df -h
            echo ""
            echo "#### Memory Usage"
            free -h
            echo ""
            echo "#### Docker Disk Usage"
            docker system df

            echo ""
            echo "### Recent Container Logs (last 200 lines per service)"
            for service in proxy backend frontend db redis; do
              echo "#### $service logs"
              docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=200 "$service" 2>&1 || echo "Service $service not found"
              echo ""
            done
          EOF

  # ============================================================================
  # STAGE 3: E2E TESTING
  # ============================================================================
  # Run end-to-end tests against the staging environment
  # Only runs if deploy-staging succeeds
  # ============================================================================

  e2e-testing:
    name: E2E Tests Against Staging
    needs: [deploy-staging]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    environment:
      name: Staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Connect to Staging via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      # ----------------------------------------------------------------
      # Run E2E Tests Against Staging
      # ----------------------------------------------------------------
      - name: Run E2E tests against staging
        id: e2e_tests
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## E2E Testing Against Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create test configuration pointing to staging
          cat > .env.e2e << EOF
          PLAYWRIGHT_BASE_URL=http://${SERVER_HOST}
          PLAYWRIGHT_HEADLESS=true
          CI=true
          EOF

          # Build test runner
          docker compose -f compose.test.yml build test-runner

          # Run E2E tests
          mkdir -p testing/reports

          docker compose -f compose.test.yml run --rm \
            --env-file .env.e2e \
            test-runner \
            bash -c "cd /app/testing/e2e && npx playwright test --reporter=html,json,list" \
            || echo "e2e_failed=true" >> $GITHUB_OUTPUT

          # Generate summary
          if [ "${{ steps.e2e_tests.outputs.e2e_failed }}" != "true" ]; then
            echo "‚úÖ E2E tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå E2E tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ github.sha }}
          path: |
            testing/e2e/playwright-report/
            testing/e2e/test-results/
          retention-days: 30
          if-no-files-found: warn

      - name: Fail if E2E tests failed
        if: steps.e2e_tests.outputs.e2e_failed == 'true'
        run: |
          echo "‚ùå E2E tests failed - blocking production deployment"
          exit 1

  # ============================================================================
  # STAGE 4: DEPLOY TO PRODUCTION
  # ============================================================================
  # Deploy to production environment
  # ONLY runs if all previous stages succeed (build, staging deploy, E2E tests)
  # ============================================================================

  deploy-production:
    name: Deploy to Production
    needs: [build-and-test, deploy-staging, e2e-testing]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy to production from main branch after all stages pass
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: Production
      url: https://yourdomain.com

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Production Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Production Server
      # ----------------------------------------------------------------
      - name: Deploy to production server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-production"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Production)
          DJANGO_SETTINGS_MODULE=config.settings.production
          DEBUG=False
          LOG_LEVEL=WARNING
          ENVIRONMENT=production

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/backend/.env.production << 'ENV_EOF'
          # Backend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Production)
          NODE_ENV=production
          ENVIRONMENT=production
          ENV_EOF

          # Create frontend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/frontend/.env.production << 'ENV_EOF'
          # Frontend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Production)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Stop Existing Containers
          # ================================================================
          echo "#### Step 1: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.production.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Create Deployment Directories
          # ================================================================
          echo "#### Step 2: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "‚úÖ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Transfer Configuration Files
          # ================================================================
          echo "#### Step 3: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true && sleep 2"

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.production.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "‚úÖ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Deploy Containers on Server
          # ================================================================
          echo "#### Step 4: Starting deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Connecting to server to pull images and start containers..." >> $GITHUB_STEP_SUMMARY
          echo "This step includes real-time health monitoring and will show detailed logs if any issues occur." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Deploy on production server with registry authentication
          # Use -tt to force pseudo-terminal allocation for better output visibility
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << 'EOF'
            set -e
            cd /home/$SERVER_USER/deployments/app-production

            echo ""
            echo "==================================================================="
            echo "PRODUCTION DEPLOYMENT - STARTING"
            echo "==================================================================="
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S %Z')"
            echo "Deploy Directory: $(pwd)"
            echo "==================================================================="
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 1: Stopping Existing Containers"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.production.yml down --remove-orphans || true
            echo "‚úÖ Existing containers stopped"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 2: Authenticating to Container Registry"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Registry: ${REGISTRY}"
            echo "User: ${GITHUB_ACTOR}"
            echo "${GITHUB_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_ACTOR} --password-stdin
            echo "‚úÖ Successfully authenticated to registry"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 3: Pulling Latest Images from Registry"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.production.yml config | grep "image:" | sed 's/^ *//' || true
            echo ""
            docker compose -f docker-compose.yml -f compose.production.yml pull
            echo "‚úÖ Images pulled successfully"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 4: Starting Services"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker compose -f docker-compose.yml -f compose.production.yml up -d --force-recreate --pull always
            echo "‚úÖ Services started - beginning health monitoring"
            echo ""

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "STEP 5: MONITORING CONTAINER HEALTH"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""

            # Give services a moment to initialize
            sleep 3

            MAX_WAIT=120  # 2 minutes max wait
            ELAPSED=0
            CHECK_INTERVAL=5
            PREVIOUS_UNHEALTHY=""

            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
              echo "-------------------------------------------------------------------"
              echo "Health Check (\${ELAPSED}s / \${MAX_WAIT}s elapsed)"
              echo "-------------------------------------------------------------------"

              # Get detailed health status of all services with health checks
              HEALTH_STATUS=\$(docker compose -f docker-compose.yml -f compose.production.yml ps --format json | \\
                jq -r 'select(.Health != "") | "\\(.Service):\\(.Health)"' 2>/dev/null || true)

              if [ -z "\$HEALTH_STATUS" ]; then
                echo "‚ö†Ô∏è No health status available yet - services still initializing..."
              else
                echo "Container Health Status:"
                echo "\$HEALTH_STATUS" | while IFS=: read -r service health; do
                  case "\$health" in
                    "healthy")
                      echo "  ‚úÖ \$service: healthy"
                      ;;
                    "starting")
                      echo "  üîÑ \$service: starting (health check in progress)"
                      ;;
                    "unhealthy")
                      echo "  ‚ùå \$service: UNHEALTHY"
                      ;;
                    *)
                      echo "  ‚ö†Ô∏è  \$service: \$health"
                      ;;
                  esac
                done
              fi

              # Get list of unhealthy services
              UNHEALTHY=\$(docker compose -f docker-compose.yml -f compose.production.yml ps --format json | \\
                jq -r 'select(.Health != "" and .Health != "healthy" and .Health != "starting") | .Service' 2>/dev/null || true)

              # Check if all services are healthy
              STARTING=\$(docker compose -f docker-compose.yml -f compose.production.yml ps --format json | \\
                jq -r 'select(.Health == "starting") | .Service' 2>/dev/null || true)

              if [ -z "\$UNHEALTHY" ] && [ -z "\$STARTING" ]; then
                echo ""
                echo "==================================================================="
                echo "‚úÖ ALL SERVICES ARE HEALTHY!"
                echo "==================================================================="
                echo ""
                docker compose -f docker-compose.yml -f compose.production.yml ps
                exit 0
              fi

              # Show logs for newly unhealthy services
              if [ -n "\$UNHEALTHY" ]; then
                echo ""
                echo "üìã Displaying logs for unhealthy containers:"
                echo ""

                for service in \$UNHEALTHY; do
                  # Only show logs if this is a newly unhealthy service
                  if ! echo "\$PREVIOUS_UNHEALTHY" | grep -q "\$service"; then
                    echo ">>> NEW UNHEALTHY SERVICE DETECTED: \$service <<<"
                  fi

                  echo "--- \$service logs (last 30 lines) ---"
                  docker compose -f docker-compose.yml -f compose.production.yml logs --tail=30 "\$service" 2>&1 || echo "Failed to retrieve logs for \$service"
                  echo ""

                  # Show detailed container inspection for health check failures
                  echo "--- \$service health check details ---"
                  CONTAINER_NAME=\$(docker compose -f docker-compose.yml -f compose.production.yml ps -q "\$service" 2>/dev/null)
                  if [ -n "\$CONTAINER_NAME" ]; then
                    docker inspect "\$CONTAINER_NAME" | jq -r '.[0].State.Health | "Health Status: " + .Status + "\nFailing Streak: " + (.FailingStreak|tostring) + "\nLast Check Output: " + (if .Log then .Log[0].Output else "No logs" end)' 2>&1 || echo "Failed to inspect container \$service"
                  fi
                  echo ""
                done

                PREVIOUS_UNHEALTHY="\$UNHEALTHY"
              fi

              # Show which services we're still waiting for
              if [ -n "\$STARTING" ]; then
                echo "‚è≥ Services still starting: \$STARTING"
              fi
              if [ -n "\$UNHEALTHY" ]; then
                echo "‚ùå Unhealthy services: \$UNHEALTHY"
              fi

              sleep \$CHECK_INTERVAL
              ELAPSED=\$((\$ELAPSED + \$CHECK_INTERVAL))
              echo ""
            done

            echo "==================================================================="
            echo "‚ùå TIMEOUT - SERVICES FAILED TO BECOME HEALTHY"
            echo "==================================================================="
            echo ""
            echo "Final service status:"
            docker compose -f docker-compose.yml -f compose.production.yml ps
            echo ""

            echo "==================================================================="
            echo "FINAL LOG DUMP - ALL SERVICES"
            echo "==================================================================="
            echo ""

            for service in proxy backend frontend db redis; do
              echo "--- \$service logs (last 200 lines) ---"
              docker compose -f docker-compose.yml -f compose.production.yml logs --tail=200 "\$service" 2>&1 || echo "Service \$service not found"
              echo ""
            done

            exit 1
          EOF

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ **Production deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Production deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify production deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for production environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "‚úÖ Production environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "‚ö†Ô∏è Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "Response: ${BODY}" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ùå Production environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Collect deployment logs on failure
        if: steps.deploy.outcome == 'failure'
        continue-on-error: true
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Deployment Failed - Diagnostic Logs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment to production failed. Collecting diagnostic information..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # SSH to server and collect logs from failed deployment
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << 'EOF'
            cd /home/${SERVER_USER}/deployments/app-production

            echo "### Container Status"
            docker compose -f docker-compose.yml -f compose.production.yml ps

            echo ""
            echo "### System Resources"
            echo "#### Disk Space"
            df -h | grep -E '(Filesystem|/dev/)' || df -h
            echo ""
            echo "#### Memory Usage"
            free -h
            echo ""
            echo "#### Docker Disk Usage"
            docker system df

            echo ""
            echo "### Recent Container Logs (last 200 lines per service)"
            for service in proxy backend frontend db redis; do
              echo "#### $service logs"
              docker compose -f docker-compose.yml -f compose.production.yml logs --tail=200 "$service" 2>&1 || echo "Service $service not found"
              echo ""
            done
          EOF

      - name: Production deployment summary
        if: success()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Application successfully deployed to production**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # FAILURE DETECTION AND ISSUE CREATION
  # ============================================================================
  # Automatically detect workflow failures and create GitHub issues
  # Runs if any previous job fails
  # ============================================================================

  detect-workflow-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure() || cancelled()
    needs: [build-and-test, deploy-staging, e2e-testing, deploy-production]
    permissions:
      issues: write
      contents: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create failure tracking issue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "## Workflow Failure Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine which stage failed
          FAILED_STAGE="Unknown"
          if [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            FAILED_STAGE="Build and Test"
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Staging"
          elif [ "${{ needs.e2e-testing.result }}" = "failure" ]; then
            FAILED_STAGE="E2E Testing"
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Production"
          fi

          # Create issue title
          ISSUE_TITLE="CI/CD Pipeline Failed: $FAILED_STAGE - Run #${{ github.run_number }}"

          # Create issue body
          cat > /tmp/issue_body.md << EOF
          # CI/CD Pipeline Failure

          ## Failure Information

          - **Failed Stage**: $FAILED_STAGE
          - **Workflow**: Unified CI/CD Pipeline
          - **Run Number**: ${{ github.run_number }}
          - **Branch**: ${{ github.ref_name }}
          - **Commit**: ${{ github.sha }}
          - **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## Pipeline Status

          - Build and Test: ${{ needs.build-and-test.result }}
          - Deploy to Staging: ${{ needs.deploy-staging.result }}
          - E2E Testing: ${{ needs.e2e-testing.result }}
          - Deploy to Production: ${{ needs.deploy-production.result }}

          ## Next Steps

          1. Review the workflow logs at the run URL above
          2. Identify the root cause of the failure
          3. Fix the issue and commit with "Fix issue #N" to auto-close this issue

          ---

          Created by: Unified CI/CD Pipeline
          EOF

          # Create the issue with available labels
          # Note: Only use labels that exist in the repository
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md \
            --label "bug" || gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md)

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')

          echo "‚úÖ Created issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
