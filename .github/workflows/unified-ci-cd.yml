name: Unified CI/CD Pipeline

# ==============================================================================
# Unified CI/CD Pipeline - Single Workflow for Complete Application Stack
# ==============================================================================
#
# Pipeline Stages:
#   1. Build and Test - Build complete stack, run all tests except E2E
#   2. Deploy to Staging - Deploy build to staging server
#   3. E2E Testing - Run E2E tests against staging environment
#   4. Deploy to Production - Deploy to production after E2E validation
#
# Features:
#   - Single docker-compose build for entire application
#   - Sequential deployment with quality gates
#   - E2E validation before production deployment
#   - Automatic failure detection and issue creation
#   - Container cleanup protocol before testing
#
# ==============================================================================

on:
  push:
    branches: [main, 'feature/**']
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose.yml'
      - 'compose.*.yml'
      - '.github/workflows/unified-ci-cd.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:

# Explicit permissions (least privilege)
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  security-events: write
  packages: write

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: BUILD AND TEST
  # ============================================================================
  # Build the complete Docker Compose stack and run all tests except E2E
  # This ensures the application builds correctly and passes all unit/integration tests
  # ============================================================================

  build-and-test:
    name: Build and Test Complete Stack
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Container Registry Configuration
      # ----------------------------------------------------------------
      # Default: GitHub Container Registry (ghcr.io)
      # Can be overridden via CONTAINER_REGISTRY environment variable
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REGISTRY_PATH="${REGISTRY}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Registry Path**: ${REGISTRY_PATH}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Authenticate to Container Registry (for pushing images)
      # ----------------------------------------------------------------
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ----------------------------------------------------------------
      # Container Cleanup Protocol (MANDATORY)
      # ----------------------------------------------------------------
      - name: Clean up existing containers
        run: |
          echo "## Container Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Stop and remove any existing containers
          docker compose down -v --remove-orphans 2>/dev/null || true

          # Verify clean state
          RUNNING_CONTAINERS=$(docker ps -q | wc -l)
          echo "Running containers after cleanup: $RUNNING_CONTAINERS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build Complete Application Stack
      # ----------------------------------------------------------------
      # Uses GitHub Actions cache backend for efficient layer caching
      # Multi-level cache fallback strategy:
      # 1. Version+branch cache (version-specific current work)
      # 2. Version+main cache (version-specific shared layers)
      # 3. Branch cache (cross-version fallback)
      # 4. Main branch cache (cross-version shared layers)
      # 5. General cache (last resort fallback)
      # ----------------------------------------------------------------
      - name: Extract backend version from config/__init__.py
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build backend development container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            backend-dev:${{ steps.backend_version.outputs.version }}
            backend-dev:latest
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}

      - name: Extract frontend version from package.json
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build frontend development container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            frontend-dev:${{ steps.frontend_version.outputs.version }}
            frontend-dev:latest
          cache-from: |
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}

      - name: Build complete application stack summary
        run: |
          echo "## Building Complete Application Stack" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Complete stack built successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show image sizes
          echo "### Container Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "(backend-dev|frontend-dev|SIZE)"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Backend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run backend tests
        run: |
          echo "## Backend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Start dependencies
          docker compose up -d db redis

          # Wait for PostgreSQL to be ready with enhanced validation
          echo "Waiting for PostgreSQL to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T db pg_isready -U postgres; do sleep 2; done'

          # Verify database can execute queries (not just accept connections)
          echo "Verifying database can execute queries..." >> $GITHUB_STEP_SUMMARY
          timeout 30 bash -c 'until docker compose exec -T db psql -U postgres -c "SELECT 1" > /dev/null 2>&1; do sleep 2; done'

          # Additional stabilization period for connection pooling initialization
          echo "Database stabilization period..." >> $GITHUB_STEP_SUMMARY
          sleep 5

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T redis redis-cli ping | grep -q PONG; do sleep 2; done'

          # Verify services are healthy before running tests
          echo "Verifying all services are healthy..." >> $GITHUB_STEP_SUMMARY
          docker compose ps
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run backend tests
          docker compose run --rm \
            -e DJANGO_SETTINGS_MODULE=config.settings.testing \
            -e SECRET_KEY=test-secret-key \
            -e USE_POSTGRES_FOR_TESTS=true \
            -e DB_HOST=db \
            -e DB_PORT=5432 \
            -e DB_NAME=backend_db \
            -e DB_USER=postgres \
            -e DB_PASSWORD=postgres \
            backend \
            pytest --cov=apps \
              --cov-report=xml \
              --cov-report=term-missing \
              --junitxml=pytest-report.xml \
              -n auto

          echo "✅ Backend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Frontend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run frontend tests
        run: |
          echo "## Frontend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run frontend tests
          docker compose run --rm frontend npm run test:run

          echo "✅ Frontend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Linting and Type Checking
      # ----------------------------------------------------------------
      - name: Run linting and type checks
        run: |
          echo "## Code Quality Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Backend linting
          docker compose run --rm backend bash -c "black --check . && isort --check-only . && flake8"
          echo "✅ Backend linting passed" >> $GITHUB_STEP_SUMMARY

          # Frontend linting
          docker compose run --rm frontend npm run lint
          echo "✅ Frontend linting passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build and Push Production Images to Registry
      # ----------------------------------------------------------------
      # After tests pass, build production-optimized images and push to registry
      # These images use the production Dockerfile target with optimizations
      # Images are pushed to registry for direct pulling by deployment servers
      # ----------------------------------------------------------------
      - name: Build and push backend production container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: production
          push: true
          no-cache: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/backend:latest
            ${{ steps.registry.outputs.registry_path }}/backend:${{ github.ref_name }}
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ github.ref_name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.backend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push frontend production container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/frontend:latest
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ github.ref_name }}
          build-args: |
            VERSION=${{ steps.frontend_version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: |
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ github.ref_name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.frontend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build production images summary
        run: |
          echo "## Production Images Published to Registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Production images built and pushed to registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show published image details
          echo "### Published Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Backend:  ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}"
          echo "Frontend: ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show all tags published
          echo "### Published Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Cleanup
      # ----------------------------------------------------------------
      - name: Cleanup after build
        if: always()
        run: |
          docker compose down -v --remove-orphans

  # ============================================================================
  # STAGE 2: DEPLOY TO STAGING
  # ============================================================================
  # Deploy the successfully built and tested application to staging environment
  # Only runs if build-and-test succeeds
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    needs: [build-and-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy from main branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: Staging
      url: https://staging.edenco.online

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Staging Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Staging Server
      # ----------------------------------------------------------------
      - name: Deploy to staging server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-staging"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Staging)
          DJANGO_SETTINGS_MODULE=config.settings.staging
          DEBUG=False
          LOG_LEVEL=INFO
          ENVIRONMENT=staging

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/backend/.env.staging << 'ENV_EOF'
          # Backend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Staging)
          NODE_ENV=production
          ENVIRONMENT=staging
          ENV_EOF

          # Create frontend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/frontend/.env.staging << 'ENV_EOF'
          # Frontend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Staging)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Database configuration
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # Create deployment directory structure
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend"

          # Transfer configuration files
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.staging.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          # Transfer environment files
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          # Deploy on staging server with registry authentication
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << EOF
            set -e
            cd /home/${SERVER_USER}/deployments/app-staging

            echo "Stopping existing containers..."
            docker compose -f docker-compose.yml -f compose.staging.yml down --remove-orphans || true

            echo "Logging in to container registry..."
            echo "${GITHUB_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_ACTOR} --password-stdin

            echo "Pulling latest images from registry..."
            docker compose -f docker-compose.yml -f compose.staging.yml pull

            echo "Starting services..."
            docker compose -f docker-compose.yml -f compose.staging.yml up -d --force-recreate --pull always

            echo "Backend startup logs (immediate check):"
            sleep 5
            docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=100 backend || true

            echo ""
            echo "Service status after startup:"
            docker compose -f docker-compose.yml -f compose.staging.yml ps
            echo ""

            echo "Waiting for services to become healthy..."
            MAX_WAIT=120  # 2 minutes max wait
            ELAPSED=0
            CHECK_INTERVAL=5

            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
              echo "Checking service health (\${ELAPSED}s elapsed)..."

              # Get health status of all services
              UNHEALTHY=\$(docker compose -f docker-compose.yml -f compose.staging.yml ps --format json | \\
                jq -r 'select(.Health != "" and .Health != "healthy") | .Service' 2>/dev/null || true)

              if [ -z "\$UNHEALTHY" ]; then
                echo "✅ All services are healthy!"
                docker compose -f docker-compose.yml -f compose.staging.yml ps
                exit 0
              fi

              echo "⚠️ Waiting for services: \$UNHEALTHY"
              sleep \$CHECK_INTERVAL
              ELAPSED=\$((\$ELAPSED + \$CHECK_INTERVAL))
            done

            echo "❌ Services failed to become healthy within \${MAX_WAIT}s"
            echo "Service status:"
            docker compose -f docker-compose.yml -f compose.staging.yml ps

            echo "Proxy logs (last 50 lines):"
            docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=50 proxy || true

            echo "Backend logs (last 50 lines):"
            docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=50 backend || true

            exit 1
          EOF

          echo "✅ Staging deployment completed" >> $GITHUB_STEP_SUMMARY

      - name: Verify staging deployment
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for staging environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "✅ Staging environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "⚠️ Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "$BODY" ]]; then
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Staging environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

  # ============================================================================
  # STAGE 3: E2E TESTING
  # ============================================================================
  # Run end-to-end tests against the staging environment
  # Only runs if deploy-staging succeeds
  # ============================================================================

  e2e-testing:
    name: E2E Tests Against Staging
    needs: [deploy-staging]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    environment:
      name: Staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Connect to Staging via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      # ----------------------------------------------------------------
      # Run E2E Tests Against Staging
      # ----------------------------------------------------------------
      - name: Run E2E tests against staging
        id: e2e_tests
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## E2E Testing Against Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create test configuration pointing to staging
          cat > .env.e2e << EOF
          PLAYWRIGHT_BASE_URL=http://${SERVER_HOST}
          PLAYWRIGHT_HEADLESS=true
          CI=true
          EOF

          # Build test runner
          docker compose -f compose.test.yml build test-runner

          # Run E2E tests
          mkdir -p testing/reports

          docker compose -f compose.test.yml run --rm \
            --env-file .env.e2e \
            test-runner \
            bash -c "cd /app/testing/e2e && npx playwright test --reporter=html,json,list" \
            || echo "e2e_failed=true" >> $GITHUB_OUTPUT

          # Generate summary
          if [ "${{ steps.e2e_tests.outputs.e2e_failed }}" != "true" ]; then
            echo "✅ E2E tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ E2E tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ github.sha }}
          path: |
            testing/e2e/playwright-report/
            testing/e2e/test-results/
          retention-days: 30
          if-no-files-found: warn

      - name: Fail if E2E tests failed
        if: steps.e2e_tests.outputs.e2e_failed == 'true'
        run: |
          echo "❌ E2E tests failed - blocking production deployment"
          exit 1

  # ============================================================================
  # STAGE 4: DEPLOY TO PRODUCTION
  # ============================================================================
  # Deploy to production environment
  # ONLY runs if all previous stages succeed (build, staging deploy, E2E tests)
  # ============================================================================

  deploy-production:
    name: Deploy to Production
    needs: [build-and-test, deploy-staging, e2e-testing]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy to production from main branch after all stages pass
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: Production
      url: https://yourdomain.com

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Production Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Production Server
      # ----------------------------------------------------------------
      - name: Deploy to production server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-production"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Production)
          DJANGO_SETTINGS_MODULE=config.settings.production
          DEBUG=False
          LOG_LEVEL=WARNING
          ENVIRONMENT=production

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/backend/.env.production << 'ENV_EOF'
          # Backend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Production)
          NODE_ENV=production
          ENVIRONMENT=production
          ENV_EOF

          # Create frontend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/frontend/.env.production << 'ENV_EOF'
          # Frontend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Production)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Database configuration
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # Create deployment directory structure
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend"

          # Transfer configuration files
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.production.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          # Transfer environment files
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          # Deploy on production server with registry authentication
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} << EOF
            set -e
            cd /home/${SERVER_USER}/deployments/app-production

            echo "Stopping existing containers..."
            docker compose -f docker-compose.yml -f compose.production.yml down --remove-orphans || true

            echo "Logging in to container registry..."
            echo "${GITHUB_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_ACTOR} --password-stdin

            echo "Pulling latest images from registry..."
            docker compose -f docker-compose.yml -f compose.production.yml pull

            echo "Starting services..."
            docker compose -f docker-compose.yml -f compose.production.yml up -d --force-recreate --pull always

            echo "Backend startup logs (immediate check):"
            sleep 5
            docker compose -f docker-compose.yml -f compose.production.yml logs --tail=100 backend || true

            echo ""
            echo "Service status after startup:"
            docker compose -f docker-compose.yml -f compose.production.yml ps
            echo ""

            echo "Waiting for services to become healthy..."
            MAX_WAIT=120  # 2 minutes max wait
            ELAPSED=0
            CHECK_INTERVAL=5

            while [ \$ELAPSED -lt \$MAX_WAIT ]; do
              echo "Checking service health (\${ELAPSED}s elapsed)..."

              # Get health status of all services
              UNHEALTHY=\$(docker compose -f docker-compose.yml -f compose.production.yml ps --format json | \\
                jq -r 'select(.Health != "" and .Health != "healthy") | .Service' 2>/dev/null || true)

              if [ -z "\$UNHEALTHY" ]; then
                echo "✅ All services are healthy!"
                docker compose -f docker-compose.yml -f compose.production.yml ps
                exit 0
              fi

              echo "⚠️ Waiting for services: \$UNHEALTHY"
              sleep \$CHECK_INTERVAL
              ELAPSED=\$((\$ELAPSED + \$CHECK_INTERVAL))
            done

            echo "❌ Services failed to become healthy within \${MAX_WAIT}s"
            echo "Service status:"
            docker compose -f docker-compose.yml -f compose.production.yml ps

            echo "Proxy logs (last 50 lines):"
            docker compose -f docker-compose.yml -f compose.production.yml logs --tail=50 proxy || true

            echo "Backend logs (last 50 lines):"
            docker compose -f docker-compose.yml -f compose.production.yml logs --tail=50 backend || true

            exit 1
          EOF

          echo "✅ Production deployment completed" >> $GITHUB_STEP_SUMMARY

      - name: Verify production deployment
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for production environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "✅ Production environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "⚠️ Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "$BODY" ]]; then
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Production environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Production deployment summary
        if: success()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Application successfully deployed to production**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # FAILURE DETECTION AND ISSUE CREATION
  # ============================================================================
  # Automatically detect workflow failures and create GitHub issues
  # Runs if any previous job fails
  # ============================================================================

  detect-workflow-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure() || cancelled()
    needs: [build-and-test, deploy-staging, e2e-testing, deploy-production]
    permissions:
      issues: write
      contents: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create failure tracking issue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "## Workflow Failure Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine which stage failed
          FAILED_STAGE="Unknown"
          if [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            FAILED_STAGE="Build and Test"
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Staging"
          elif [ "${{ needs.e2e-testing.result }}" = "failure" ]; then
            FAILED_STAGE="E2E Testing"
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Production"
          fi

          # Create issue title
          ISSUE_TITLE="CI/CD Pipeline Failed: $FAILED_STAGE - Run #${{ github.run_number }}"

          # Create issue body
          cat > /tmp/issue_body.md << EOF
          # CI/CD Pipeline Failure

          ## Failure Information

          - **Failed Stage**: $FAILED_STAGE
          - **Workflow**: Unified CI/CD Pipeline
          - **Run Number**: ${{ github.run_number }}
          - **Branch**: ${{ github.ref_name }}
          - **Commit**: ${{ github.sha }}
          - **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## Pipeline Status

          - Build and Test: ${{ needs.build-and-test.result }}
          - Deploy to Staging: ${{ needs.deploy-staging.result }}
          - E2E Testing: ${{ needs.e2e-testing.result }}
          - Deploy to Production: ${{ needs.deploy-production.result }}

          ## Next Steps

          1. Review the workflow logs at the run URL above
          2. Identify the root cause of the failure
          3. Fix the issue and commit with "Fix issue #N" to auto-close this issue

          ---

          Created by: Unified CI/CD Pipeline
          EOF

          # Create the issue with available labels
          # Note: Only use labels that exist in the repository
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md \
            --label "bug" || gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md)

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')

          echo "✅ Created issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
