name: Unified CI/CD Pipeline

# ==============================================================================
# Unified CI/CD Pipeline - Single Workflow for Complete Application Stack
# ==============================================================================
#
# Pipeline Stages:
#   1. Build and Test - Build complete stack, run all tests except E2E
#   2. Deploy to Staging - Deploy build to staging server
#   3. E2E Testing - Run E2E tests against staging environment
#   4. Deploy to Production - Deploy to production after E2E validation
#
# Deployment Strategy:
#   - feature/* branches: Build → Test → Deploy to Staging → E2E Test
#   - main branch: Build → Test → Deploy to Staging → E2E Test → Deploy to Production
#   - Pull requests: Build → Test only (no deployment)
#
# Features:
#   - Single docker-compose build for entire application
#   - Sequential deployment with quality gates
#   - E2E validation before production deployment
#   - Automatic failure detection and issue creation
#   - Container cleanup protocol before testing
#
# ==============================================================================

on:
  push:
    branches: [main, 'feature/**']
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose.yml'
      - 'compose.*.yml'
      - '.github/workflows/unified-ci-cd.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip backend and frontend tests (for deployment testing only)'
        required: false
        type: boolean
        default: false

# Explicit permissions (least privilege)
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  security-events: write
  packages: write

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: BUILD AND TEST
  # ============================================================================
  # Build the complete Docker Compose stack and run all tests except E2E
  # This ensures the application builds correctly and passes all unit/integration tests
  # ============================================================================

  build-and-test:
    name: Build and Test Complete Stack
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Sanitize Branch Name for Docker Tags
      # ----------------------------------------------------------------
      # Docker image tags cannot contain forward slashes, which are present
      # in branch names like "292/merge" from GitHub pull requests.
      # This step converts "/" to "-" for safe Docker tag usage.
      # ----------------------------------------------------------------
      - name: Sanitize branch name for Docker tags
        id: sanitized_ref
        run: |
          # Replace forward slashes with hyphens for Docker tag compatibility
          SANITIZED_REF=$(echo '${{ github.ref_name }}' | sed 's/\//-/g')
          echo "ref=$SANITIZED_REF" >> $GITHUB_OUTPUT
          echo "Sanitized branch name: $GITHUB_REF_NAME -> $SANITIZED_REF" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Container Registry Configuration
      # ----------------------------------------------------------------
      # Default: GitHub Container Registry (ghcr.io)
      # Can be overridden via CONTAINER_REGISTRY environment variable
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REGISTRY_PATH="${REGISTRY}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Registry Path**: ${REGISTRY_PATH}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Authenticate to Container Registry (for pushing images)
      # ----------------------------------------------------------------
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ----------------------------------------------------------------
      # Container Cleanup Protocol (MANDATORY)
      # ----------------------------------------------------------------
      - name: Clean up existing containers
        run: |
          echo "## Container Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Stop and remove any existing containers
          docker compose down -v --remove-orphans 2>/dev/null || true

          # Verify clean state
          RUNNING_CONTAINERS=$(docker ps -q | wc -l)
          echo "Running containers after cleanup: $RUNNING_CONTAINERS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build Complete Application Stack
      # ----------------------------------------------------------------
      # Uses GitHub Actions cache backend for efficient layer caching
      # Multi-level cache fallback strategy:
      # 1. Version+branch cache (version-specific current work)
      # 2. Version+main cache (version-specific shared layers)
      # 3. Branch cache (cross-version fallback)
      # 4. Main branch cache (cross-version shared layers)
      # 5. General cache (last resort fallback)
      # ----------------------------------------------------------------
      - name: Extract backend version from config/__init__.py
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Build backend development container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            backend-dev:${{ steps.backend_version.outputs.version }}
            backend-dev:latest
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-dev-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}

      - name: Extract frontend version from package.json
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "Extracted frontend version: $FRONTEND_VERSION"

      - name: Build frontend development container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: development
          push: false
          load: true
          tags: |
            frontend-dev:${{ steps.frontend_version.outputs.version }}
            frontend-dev:latest
          cache-from: |
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-dev-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}

      - name: Build complete application stack summary
        run: |
          echo "## Building Complete Application Stack" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Complete stack built successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show image sizes
          echo "### Container Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "(backend-dev|frontend-dev|SIZE)"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Test Skip Notice
      # ----------------------------------------------------------------
      - name: Tests skipped notice
        if: ${{ inputs.skip_tests }}
        run: |
          echo "## ⚠️ Tests Skipped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Backend and frontend tests were skipped as requested." >> $GITHUB_STEP_SUMMARY
          echo "**This should only be used for deployment testing purposes.**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Backend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run backend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Backend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Start dependencies
          docker compose up -d db redis

          # Wait for PostgreSQL to be ready with enhanced validation
          echo "Waiting for PostgreSQL to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T db pg_isready -U postgres; do sleep 2; done'

          # Verify database can execute queries (not just accept connections)
          echo "Verifying database can execute queries..." >> $GITHUB_STEP_SUMMARY
          timeout 30 bash -c 'until docker compose exec -T db psql -U postgres -c "SELECT 1" > /dev/null 2>&1; do sleep 2; done'

          # Additional stabilization period for connection pooling initialization
          echo "Database stabilization period..." >> $GITHUB_STEP_SUMMARY
          sleep 5

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..." >> $GITHUB_STEP_SUMMARY
          timeout 60 bash -c 'until docker compose exec -T redis redis-cli ping | grep -q PONG; do sleep 2; done'

          # Verify services are healthy before running tests
          echo "Verifying all services are healthy..." >> $GITHUB_STEP_SUMMARY
          docker compose ps
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run backend tests
          docker compose run --rm \
            -e DJANGO_SETTINGS_MODULE=config.settings.testing \
            -e SECRET_KEY=test-secret-key \
            -e USE_POSTGRES_FOR_TESTS=true \
            -e DB_HOST=db \
            -e DB_PORT=5432 \
            -e DB_NAME=backend_db \
            -e DB_USER=postgres \
            -e DB_PASSWORD=postgres \
            backend \
            pytest --cov=apps \
              --cov-report=xml \
              --cov-report=term-missing \
              --junitxml=pytest-report.xml \
              -n auto

          echo "✅ Backend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Frontend Tests (Unit + Integration)
      # ----------------------------------------------------------------
      - name: Run frontend tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "## Frontend Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run frontend tests
          docker compose run --rm frontend npm run test:run

          echo "✅ Frontend tests passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Linting and Type Checking
      # ----------------------------------------------------------------
      - name: Run linting and type checks
        run: |
          echo "## Code Quality Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Backend linting
          docker compose run --rm backend bash -c "black --check . && isort --check-only . && flake8"
          echo "✅ Backend linting passed" >> $GITHUB_STEP_SUMMARY

          # Frontend linting
          docker compose run --rm frontend npm run lint
          echo "✅ Frontend linting passed" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Build and Push Production Images to Registry
      # ----------------------------------------------------------------
      # After tests pass, build production-optimized images and push to registry
      # These images use the production Dockerfile target with optimizations
      # Images are pushed to registry for direct pulling by deployment servers
      # ----------------------------------------------------------------
      - name: Build and push backend production container
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: production
          push: true
          no-cache: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/backend:latest
            ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.sanitized_ref.outputs.ref }}
          build-args: |
            APP_VERSION=${{ steps.backend_version.outputs.version }}
          cache-from: |
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=backend-prod-v${{ steps.backend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.backend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push frontend production container
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}
            ${{ steps.registry.outputs.registry_path }}/frontend:latest
            ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.sanitized_ref.outputs.ref }}
          build-args: |
            VERSION=${{ steps.frontend_version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: |
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
            type=gha,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-main
          cache-to: type=gha,mode=max,scope=frontend-prod-v${{ steps.frontend_version.outputs.version }}-${{ steps.sanitized_ref.outputs.ref }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.frontend_version.outputs.version }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build production images summary
        run: |
          echo "## Production Images Published to Registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Production images built and pushed to registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show published image details
          echo "### Published Images" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Backend:  ${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}"
          echo "Frontend: ${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show all tags published
          echo "### Published Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.backend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}\` (version)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.frontend_version.outputs.version }}-${{ github.sha }}\` (version+sha)" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\` (latest)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ github.ref_name }}\` (branch)" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Cleanup
      # ----------------------------------------------------------------
      - name: Cleanup after build
        if: always()
        run: |
          docker compose down -v --remove-orphans

  # ============================================================================
  # STAGE 2: DEPLOY TO STAGING
  # ============================================================================
  # Deploy the successfully built and tested application to staging environment
  # Only runs if build-and-test succeeds
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    needs: [build-and-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Deploy from main branch OR feature branches (via push or manual trigger)
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/feature/')) && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment:
      name: Staging
      url: https://staging.edenco.online

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Staging Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Staging Server
      # ----------------------------------------------------------------
      - name: Deploy to staging server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-staging"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Staging)
          DJANGO_SETTINGS_MODULE=config.settings.staging
          DEBUG=False
          LOG_LEVEL=INFO
          ENVIRONMENT=staging

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/backend/.env.staging << 'ENV_EOF'
          # Backend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Staging)
          NODE_ENV=production
          ENVIRONMENT=staging
          ENV_EOF

          # Create frontend .env.staging (loaded by compose.staging.yml)
          cat > /tmp/deployment/frontend/.env.staging << 'ENV_EOF'
          # Frontend Staging Environment Configuration
          # Additional staging-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Staging)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_staging_db
          DB_USER=backend_staging_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Clean Cache Volumes
          # ================================================================
          echo "#### Step 1: Cleaning cache volumes" >> $GITHUB_STEP_SUMMARY
          echo "Removing stale cache volumes to prevent serving outdated content..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            cd ${DEPLOY_DIR}

            echo '=== Cache Volume Cleanup ==='
            echo 'Removing cache-only volumes to prevent stale content:'
            echo ''

            # Remove nginx cache volumes (static and media file caches)
            # These can serve stale content after deployments if not cleared
            docker volume rm app-staging_proxy_cache_static 2>/dev/null && echo '✅ Removed proxy_cache_static' || echo 'ℹ️  proxy_cache_static not found (first deployment or already clean)'
            docker volume rm app-staging_proxy_cache_media 2>/dev/null && echo '✅ Removed proxy_cache_media' || echo 'ℹ️  proxy_cache_media not found (first deployment or already clean)'

            # Remove Redis data volume to flush all cache entries
            # This prevents old application state from persisting across deployments
            docker volume rm app-staging_redis_data 2>/dev/null && echo '✅ Removed redis_data (cache will be rebuilt)' || echo 'ℹ️  redis_data not found (first deployment or already clean)'

            echo ''
            echo '=== Preserved Data Volumes ==='
            echo 'The following volumes are PRESERVED (user data):'
            echo '  - postgres_data (database - contains user data)'
            echo '  - backend_media (user uploads)'
            echo '  - backend_static (collected static files - will be regenerated)'
            echo '  - proxy_logs (nginx access/error logs for debugging)'
            echo ''
          " | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Cache volumes cleaned successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Stop Existing Containers
          # ================================================================
          echo "#### Step 2: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.staging.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Create Deployment directories
          # ================================================================
          echo "#### Step 3: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "✅ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Transfer Configuration Files
          # ================================================================
          echo "#### Step 4: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            # Ensure deployment directory ownership is correct
            sudo chown -R ${SERVER_USER}:${SERVER_USER} ${DEPLOY_DIR} 2>/dev/null || true

            # Remove any read-only flags and ensure write permissions
            chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true

            # Wait for file locks to be released after container shutdown
            sleep 5

            # Verify directories are writable
            if [ ! -w \"${DEPLOY_DIR}/nginx\" ]; then
              echo \"Warning: ${DEPLOY_DIR}/nginx is still not writable after permission fix\"
              ls -ld ${DEPLOY_DIR}/nginx
            fi
          "

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.staging.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.production.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.production.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.staging \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "Transferring deployment script..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            .github/scripts/deploy-staging.sh \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/deploy-staging.sh

          echo "✅ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 5: Execute Deployment Script on Server
          # ================================================================
          echo "#### Step 5: Executing deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Running deployment script with health monitoring..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Execute deployment script on server
          # Use single quotes to prevent variable expansion on the client side
          # and properly escape variables for the remote shell
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && \
            REGISTRY='${REGISTRY}' \
            GITHUB_ACTOR='${GITHUB_ACTOR}' \
            GITHUB_TOKEN='${GITHUB_TOKEN}' \
            REDIS_PASSWORD='${REDIS_PASSWORD//\'/\'\\\'\'}' \
            bash deploy-staging.sh"

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "✅ **Staging deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Staging deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify staging deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          echo "## Verifying Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Validate that SERVER_HOST is defined
          if [[ -z "${SERVER_HOST:-}" ]]; then
            echo "❌ ERROR: SERVER_HOST secret is not configured" >> $GITHUB_STEP_SUMMARY
            echo "Please configure the SERVER_HOST secret in the 'Staging' environment settings" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # ================================================================
          # STEP 1: Test Basic Network Connectivity
          # ================================================================
          echo "### Step 1: Testing Network Connectivity" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Try to ping the server (if available) or use nc to test port
          if command -v nc &> /dev/null; then
            if nc -zv -w5 "${SERVER_HOST}" 80 2>&1; then
              echo "✅ Port 80 is reachable on ${SERVER_HOST//?/*}" >> $GITHUB_STEP_SUMMARY
            else
              echo "❌ Cannot reach port 80 on ${SERVER_HOST//?/*}" >> $GITHUB_STEP_SUMMARY
              echo "This might indicate a Tailscale connectivity issue or nginx not running" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Wait for Container Health Checks to Complete
          # ================================================================
          # Backend has start_period: 200s in staging, meaning health checks
          # don't even start counting until 200 seconds have elapsed.
          # We need to wait for Docker health checks to pass first before
          # trying the HTTP endpoint.
          # ================================================================
          echo "### Step 2: Waiting for Container Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note**: Backend container has 200s start period for migrations and collectstatic" >> $GITHUB_STEP_SUMMARY
          echo "Checking container status on remote server..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # SSH to server and monitor container health status
          # Maximum wait time: 300 seconds (5 minutes) - longer than backend start_period
          MAX_CONTAINER_WAIT=300
          CONTAINER_CHECK_INTERVAL=15
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_CONTAINER_WAIT ]; do
            echo "Container health check (${ELAPSED}s / ${MAX_CONTAINER_WAIT}s elapsed)..." >> $GITHUB_STEP_SUMMARY

            # Get container health status from remote server
            CONTAINER_STATUS=$(ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
              "cd /home/${SERVER_USER}/deployments/app-staging && \
               docker compose -f docker-compose.yml -f compose.staging.yml ps --format json 2>/dev/null | \
               jq -r 'select(.Service == \"backend\" or .Service == \"proxy\") | \"\(.Service):\(.Health)\"' 2>/dev/null" || echo "error")

            if [[ "$CONTAINER_STATUS" == "error" ]]; then
              echo "⚠️ Could not retrieve container status from server" >> $GITHUB_STEP_SUMMARY
            else
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$CONTAINER_STATUS" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY

              # Check if backend and proxy are both healthy
              BACKEND_HEALTHY=$(echo "$CONTAINER_STATUS" | grep "backend:healthy" || echo "")
              PROXY_HEALTHY=$(echo "$CONTAINER_STATUS" | grep "proxy:healthy" || echo "")

              if [[ -n "$BACKEND_HEALTHY" && -n "$PROXY_HEALTHY" ]]; then
                echo "✅ All critical containers are healthy!" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                break
              else
                # Show which containers are still starting
                if [[ -z "$BACKEND_HEALTHY" ]]; then
                  BACKEND_STATUS=$(echo "$CONTAINER_STATUS" | grep "backend:" | cut -d: -f2 || echo "unknown")
                  echo "⏳ Backend: $BACKEND_STATUS" >> $GITHUB_STEP_SUMMARY
                fi
                if [[ -z "$PROXY_HEALTHY" ]]; then
                  PROXY_STATUS=$(echo "$CONTAINER_STATUS" | grep "proxy:" | cut -d: -f2 || echo "unknown")
                  echo "⏳ Proxy: $PROXY_STATUS" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            fi

            if [[ $ELAPSED -ge $MAX_CONTAINER_WAIT ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "❌ Containers did not become healthy within ${MAX_CONTAINER_WAIT}s" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Final container status:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
                "cd /home/${SERVER_USER}/deployments/app-staging && \
                 docker compose -f docker-compose.yml -f compose.staging.yml ps" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              exit 1
            fi

            sleep $CONTAINER_CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CONTAINER_CHECK_INTERVAL))
            echo "" >> $GITHUB_STEP_SUMMARY
          done

          # ================================================================
          # STEP 3: Verify Health Endpoint via HTTP
          # ================================================================
          # Now that containers are healthy, verify the health endpoint
          # responds correctly via HTTP
          # ================================================================
          echo "### Step 3: Verifying Health Endpoint via HTTP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic
          # Shorter timeout now since containers are already healthy
          MAX_HTTP_RETRIES=6
          HTTP_RETRY_DELAY=10
          INITIAL_BUFFER_DELAY=15  # Buffer period after containers become healthy
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Target endpoint: http://[MASKED_HOST]/api/v1/status/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Wait additional buffer period for backend to fully initialize
          echo "⏳ Waiting ${INITIAL_BUFFER_DELAY}s buffer period for backend initialization..." >> $GITHUB_STEP_SUMMARY
          echo "(Containers are healthy, but backend may need time to complete startup)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          sleep $INITIAL_BUFFER_DELAY

          for i in $(seq 1 $MAX_HTTP_RETRIES); do
            echo "HTTP health check attempt $i/$MAX_HTTP_RETRIES..." >> $GITHUB_STEP_SUMMARY

            # Use curl with timeout and comprehensive diagnostics
            CURL_OUTPUT=$(mktemp)
            CURL_HEADERS=$(mktemp)
            CURL_VERBOSE=$(mktemp)
            CURL_EXIT_CODE=0

            # Capture full response with headers and verbose output for debugging
            if curl --connect-timeout 10 \
                    --max-time 15 \
                    -s -S \
                    -D "$CURL_HEADERS" \
                    -w "\nHTTP_CODE:%{http_code}\nTIME_TOTAL:%{time_total}\nTIME_CONNECT:%{time_connect}" \
                    -o "$CURL_OUTPUT" \
                    "$HEALTH_URL" 2> "$CURL_VERBOSE"; then
              CURL_EXIT_CODE=0
            else
              CURL_EXIT_CODE=$?
            fi

            # Read the response body
            if [[ -f "$CURL_OUTPUT" ]]; then
              BODY=$(cat "$CURL_OUTPUT")
            else
              BODY=""
            fi

            # Read response headers
            if [[ -f "$CURL_HEADERS" ]]; then
              HEADERS=$(cat "$CURL_HEADERS")
            else
              HEADERS=""
            fi

            # Extract metrics from verbose output
            if [[ -f "$CURL_VERBOSE" ]]; then
              VERBOSE_OUTPUT=$(cat "$CURL_VERBOSE")
            else
              VERBOSE_OUTPUT=""
            fi

            # Extract HTTP code and timing info
            HTTP_CODE=$(echo "$VERBOSE_OUTPUT" | grep "^HTTP_CODE:" | cut -d: -f2 || echo "000")
            TIME_TOTAL=$(echo "$VERBOSE_OUTPUT" | grep "^TIME_TOTAL:" | cut -d: -f2 || echo "N/A")
            TIME_CONNECT=$(echo "$VERBOSE_OUTPUT" | grep "^TIME_CONNECT:" | cut -d: -f2 || echo "N/A")

            echo "HTTP Status: $HTTP_CODE (curl exit code: $CURL_EXIT_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "Response time: ${TIME_TOTAL}s (connect: ${TIME_CONNECT}s)" >> $GITHUB_STEP_SUMMARY

            # Handle different response scenarios
            if [[ "$HTTP_CODE" == "000" ]]; then
              echo "⚠️ Failed to connect to health endpoint" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Connection Diagnostics:**" >> $GITHUB_STEP_SUMMARY
              echo "- Curl exit code: $CURL_EXIT_CODE" >> $GITHUB_STEP_SUMMARY

              # Common curl exit codes for debugging
              case $CURL_EXIT_CODE in
                7)
                  echo "- Error type: Failed to connect to host" >> $GITHUB_STEP_SUMMARY
                  echo "- Likely cause: Nginx proxy layer not accessible or not routing requests" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **PROXY LAYER**" >> $GITHUB_STEP_SUMMARY
                  ;;
                28)
                  echo "- Error type: Operation timeout" >> $GITHUB_STEP_SUMMARY
                  echo "- Likely cause: Backend responding too slowly or hanging" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **BACKEND LAYER**" >> $GITHUB_STEP_SUMMARY
                  ;;
                52)
                  echo "- Error type: Server returned nothing (empty reply)" >> $GITHUB_STEP_SUMMARY
                  echo "- Likely cause: Backend crashed or restarting" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **BACKEND LAYER**" >> $GITHUB_STEP_SUMMARY
                  ;;
                56)
                  echo "- Error type: Failure receiving network data" >> $GITHUB_STEP_SUMMARY
                  echo "- Likely cause: Connection lost mid-transfer" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **PROXY OR BACKEND LAYER**" >> $GITHUB_STEP_SUMMARY
                  ;;
                *)
                  echo "- Error type: Unexpected curl error" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **UNKNOWN - Check both proxy and backend**" >> $GITHUB_STEP_SUMMARY
                  ;;
              esac
              echo "" >> $GITHUB_STEP_SUMMARY
            elif [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              if [[ -n "$BODY" ]]; then
                STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4 || echo "unknown")

                if [[ "$STATUS" == "healthy" ]]; then
                  echo "✅ Staging environment is healthy and responding!" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Response Details:**" >> $GITHUB_STEP_SUMMARY
                  echo '```json' >> $GITHUB_STEP_SUMMARY
                  echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY

                  # Clean up temp files
                  rm -f "$CURL_OUTPUT" "$CURL_HEADERS" "$CURL_VERBOSE"
                  exit 0
                else
                  echo "⚠️ Service responded but status is: $STATUS (expected 'healthy')" >> $GITHUB_STEP_SUMMARY
                  echo "- Check layer: **BACKEND LAYER** - Backend is accessible but reporting unhealthy status" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Response Body:**" >> $GITHUB_STEP_SUMMARY
                  echo '```json' >> $GITHUB_STEP_SUMMARY
                  echo "$BODY" | head -c 1000 >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                fi
              else
                echo "⚠️ Received 200 OK but no response body" >> $GITHUB_STEP_SUMMARY
                echo "- Check layer: **BACKEND LAYER** - Response headers indicate success but no content returned" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            elif [[ "$HTTP_CODE" == "502" ]]; then
              echo "⚠️ Bad Gateway (HTTP 502) - proxy received invalid response from backend" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **BACKEND LAYER** - Backend is not responding correctly or crashed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            elif [[ "$HTTP_CODE" == "503" ]]; then
              echo "⚠️ Service Unavailable (HTTP 503) - backend temporarily unavailable" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **BACKEND LAYER** - Backend may still be starting up or overloaded" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            elif [[ "$HTTP_CODE" == "504" ]]; then
              echo "⚠️ Gateway Timeout (HTTP 504) - backend didn't respond in time" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **BACKEND LAYER** - Backend processing request too slowly" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            elif [[ "$HTTP_CODE" =~ ^30[1-8]$ ]]; then
              echo "⚠️ Redirect Response (HTTP $HTTP_CODE) - unexpected redirect" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **BACKEND LAYER** - Health endpoint may not be exempt from SSL redirect" >> $GITHUB_STEP_SUMMARY
              echo "- Verify SECURE_REDIRECT_EXEMPT includes /api/v1/status/ in staging settings" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers (showing redirect location):**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "**Response Body:**" >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -c 500 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            elif [[ "$HTTP_CODE" == "404" ]]; then
              echo "⚠️ Not Found (HTTP 404) - endpoint does not exist" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **PROXY LAYER** - Nginx may not be routing /api/v1/status/ to backend" >> $GITHUB_STEP_SUMMARY
              echo "- Verify nginx configuration includes location /api/ proxy_pass directive" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️ Unexpected HTTP Response (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
              echo "- Check layer: **UNKNOWN - Review headers and body to determine layer**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Response Headers:**" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$HEADERS" | head -n 20 >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "**Response Body:**" >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -c 1000 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            # Clean up temp files
            rm -f "$CURL_OUTPUT" "$CURL_HEADERS" "$CURL_VERBOSE"

            if [[ $i -lt $MAX_HTTP_RETRIES ]]; then
              echo "Waiting ${HTTP_RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              sleep $HTTP_RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Staging environment health check failed after $MAX_HTTP_RETRIES HTTP attempts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Troubleshooting Guide" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Quick Diagnostics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Run these commands on the staging server to diagnose the issue:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# SSH to staging server" >> $GITHUB_STEP_SUMMARY
          echo "ssh ${SERVER_USER}@${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Navigate to deployment directory" >> $GITHUB_STEP_SUMMARY
          echo "cd /home/${SERVER_USER}/deployments/app-staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 1. Check container health status" >> $GITHUB_STEP_SUMMARY
          echo "docker compose -f docker-compose.yml -f compose.staging.yml ps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 2. Test health endpoint directly from server (bypass network issues)" >> $GITHUB_STEP_SUMMARY
          echo "curl -v http://localhost/api/v1/status/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 3. Check if backend is accessible directly (bypass nginx)" >> $GITHUB_STEP_SUMMARY
          echo "curl -v http://localhost:8000/api/v1/status/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 4. Check nginx access logs for routing issues" >> $GITHUB_STEP_SUMMARY
          echo "docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=50 proxy | grep status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 5. Check backend application logs for errors" >> $GITHUB_STEP_SUMMARY
          echo "docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=100 backend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 6. Check if nginx is routing correctly" >> $GITHUB_STEP_SUMMARY
          echo "docker compose -f docker-compose.yml -f compose.staging.yml exec proxy nginx -t" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 7. Verify network connectivity between containers" >> $GITHUB_STEP_SUMMARY
          echo "docker compose -f docker-compose.yml -f compose.staging.yml exec proxy curl -v http://backend:8000/api/v1/status/" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Layer-Specific Diagnostics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**If PROXY LAYER is suspected:**" >> $GITHUB_STEP_SUMMARY
          echo "- Check nginx configuration: \`docker compose exec proxy cat /etc/nginx/nginx.conf | grep -A 20 'location /api'\`" >> $GITHUB_STEP_SUMMARY
          echo "- Verify proxy can reach backend: \`docker compose exec proxy curl http://backend:8000/api/v1/status/\`" >> $GITHUB_STEP_SUMMARY
          echo "- Check proxy logs: \`docker compose logs proxy | tail -100\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**If BACKEND LAYER is suspected:**" >> $GITHUB_STEP_SUMMARY
          echo "- Check if backend is listening: \`docker compose exec backend netstat -tlnp | grep 8000\`" >> $GITHUB_STEP_SUMMARY
          echo "- Verify Django settings: \`docker compose exec backend python manage.py check\`" >> $GITHUB_STEP_SUMMARY
          echo "- Check SECURE_REDIRECT_EXEMPT: \`docker compose exec backend python manage.py shell -c 'from django.conf import settings; print(settings.SECURE_REDIRECT_EXEMPT)'\`" >> $GITHUB_STEP_SUMMARY
          echo "- Test health endpoint inside container: \`docker compose exec backend curl http://localhost:8000/api/v1/status/\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Common Issues and Solutions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Redirect Loop (HTTP 301/302)**: Health endpoint not exempt from SSL redirect" >> $GITHUB_STEP_SUMMARY
          echo "   - Solution: Verify \`SECURE_REDIRECT_EXEMPT\` in staging settings includes \`/api/v1/status/\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. **Bad Gateway (HTTP 502)**: Backend crashed or not responding" >> $GITHUB_STEP_SUMMARY
          echo "   - Solution: Check backend logs for crashes, verify backend container is healthy" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "3. **Service Unavailable (HTTP 503)**: Backend not ready or overloaded" >> $GITHUB_STEP_SUMMARY
          echo "   - Solution: Increase health check buffer period, check backend resource usage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "4. **Connection Refused (curl exit code 7)**: Nginx not running or not routing" >> $GITHUB_STEP_SUMMARY
          echo "   - Solution: Check nginx container status, verify nginx configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "5. **Timeout (curl exit code 28)**: Backend processing too slowly" >> $GITHUB_STEP_SUMMARY
          echo "   - Solution: Check backend performance, verify database connectivity" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Fetch logs from server for debugging
          echo "### Backend Application Logs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "(Last 50 lines - check for errors, warnings, or unexpected behavior)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd /home/${SERVER_USER}/deployments/app-staging && \
             docker compose -f docker-compose.yml -f compose.staging.yml logs --tail=50 backend" >> $GITHUB_STEP_SUMMARY || echo "Failed to fetch backend logs"
          echo '```' >> $GITHUB_STEP_SUMMARY

          exit 1

  # ============================================================================
  # DIAGNOSTIC COLLECTION - STAGING
  # ============================================================================
  # Collect comprehensive diagnostics if staging deployment fails
  # ============================================================================

  collect-staging-diagnostics:
    name: Collect Staging Diagnostics
    needs: [deploy-staging]
    if: failure() && needs.deploy-staging.result == 'failure'
    uses: ./.github/workflows/collect-deployment-diagnostics.yml
    with:
      environment: Staging
      compose_file: compose.staging.yml
    secrets:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  # ============================================================================
  # STAGE 3: E2E TESTING
  # ============================================================================
  # Run end-to-end tests against the staging environment
  # Only runs if deploy-staging succeeds
  # ============================================================================

  e2e-testing:
    name: E2E Tests Against Staging
    needs: [deploy-staging]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    # Run E2E tests when staging deployment succeeds (main or feature branches)
    if: success()
    environment:
      name: Staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------
      # Connect to Staging via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      # ----------------------------------------------------------------
      # Run E2E Tests Against Staging
      # ----------------------------------------------------------------
      - name: Run E2E tests against staging
        id: e2e_tests
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## E2E Testing Against Staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create test configuration pointing to staging
          cat > .env.e2e << EOF
          PLAYWRIGHT_BASE_URL=http://${SERVER_HOST}
          PLAYWRIGHT_HEADLESS=true
          CI=true
          EOF

          # Build test runner
          docker compose -f compose.test.yml build test-runner

          # Run E2E tests
          mkdir -p testing/reports

          docker compose -f compose.test.yml run --rm \
            --env-file .env.e2e \
            test-runner \
            bash -c "cd /app/testing/e2e && npx playwright test --reporter=html,json,list" \
            || echo "e2e_failed=true" >> $GITHUB_OUTPUT

          # Generate summary
          if [ "${{ steps.e2e_tests.outputs.e2e_failed }}" != "true" ]; then
            echo "✅ E2E tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ E2E tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ github.sha }}
          path: |
            testing/e2e/playwright-report/
            testing/e2e/test-results/
          retention-days: 30
          if-no-files-found: warn

      - name: Fail if E2E tests failed
        if: steps.e2e_tests.outputs.e2e_failed == 'true'
        run: |
          echo "❌ E2E tests failed - blocking production deployment"
          exit 1

  # ============================================================================
  # STAGE 4: DEPLOY TO PRODUCTION
  # ============================================================================
  # Deploy to production environment
  # ONLY runs if all previous stages succeed (build, staging deploy, E2E tests)
  # ============================================================================

  deploy-production:
    name: Deploy to Production
    needs: [build-and-test, deploy-staging, e2e-testing]
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    # Only deploy to production from main branch after all stages pass (via push or manual trigger)
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment:
      name: Production
      url: https://yourdomain.com

    defaults:
      run:
        # Fail on unset variables (-u), exit on error (-e), fail on pipe errors (-o pipefail)
        # This prevents silent failures from undefined variables
        # Note: Use ${VAR:-} syntax if you need to handle optional variables
        shell: bash -euo pipefail {0}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Extract versions for deployment (same as build-and-test)
      - name: Extract backend version
        id: backend_version
        run: |
          BACKEND_VERSION=$(grep -E "^__version__\s*=\s*" backend/config/__init__.py | cut -d'"' -f2)
          echo "version=$BACKEND_VERSION" >> $GITHUB_OUTPUT
          echo "Backend version: $BACKEND_VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Extract frontend version
        id: frontend_version
        run: |
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          echo "version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
          echo "Frontend version: $FRONTEND_VERSION" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Configure Registry for Deployment
      # ----------------------------------------------------------------
      - name: Configure container registry
        id: registry
        run: |
          REGISTRY="${CONTAINER_REGISTRY:-ghcr.io}"
          # Docker registry repository names must be lowercase
          REPOSITORY_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')
          REGISTRY_PATH="${REGISTRY}/${REPOSITORY_OWNER}"

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository_owner=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "registry_path=${REGISTRY_PATH}" >> $GITHUB_OUTPUT

          echo "## Container Registry Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry**: ${REGISTRY}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Owner**: ${REPOSITORY_OWNER}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY

      # ----------------------------------------------------------------
      # Connect to Production Server via Tailscale
      # ----------------------------------------------------------------
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH for production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${SERVER_HOST} >> ~/.ssh/known_hosts

      # ----------------------------------------------------------------
      # Deploy to Production Server
      # ----------------------------------------------------------------
      - name: Deploy to production server
        id: deploy
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "## Deploying to Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          DEPLOY_DIR="/home/${SERVER_USER}/deployments/app-production"
          REGISTRY_PATH="${{ steps.registry.outputs.registry_path }}"

          # Log deployment details for visibility
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Server**: ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: ${DEPLOY_DIR}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${REGISTRY_PATH}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${REGISTRY_PATH}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ steps.registry.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Deployment Progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create environment files locally before transfer
          mkdir -p /tmp/deployment/backend /tmp/deployment/frontend

          # Create backend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/backend/.env.docker << ENV_EOF
          # Backend Docker Environment Configuration (Production)
          DJANGO_SETTINGS_MODULE=config.settings.production
          DEBUG=False
          LOG_LEVEL=WARNING
          ENVIRONMENT=production

          # Security
          SECRET_KEY=${SECRET_KEY}
          ALLOWED_HOSTS=${SERVER_HOST},localhost,127.0.0.1,backend

          # Database
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD=${DB_PASSWORD}

          # Redis
          REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1

          # CORS
          CORS_ALLOWED_ORIGINS=https://${SERVER_HOST}
          CSRF_TRUSTED_ORIGINS=https://${SERVER_HOST}
          ENV_EOF

          # Create backend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/backend/.env.production << 'ENV_EOF'
          # Backend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create frontend .env.docker (required by base docker-compose.yml)
          cat > /tmp/deployment/frontend/.env.docker << 'ENV_EOF'
          # Frontend Docker Environment Configuration (Production)
          NODE_ENV=production
          ENVIRONMENT=production
          ENV_EOF

          # Create frontend .env.production (loaded by compose.production.yml)
          cat > /tmp/deployment/frontend/.env.production << 'ENV_EOF'
          # Frontend Production Environment Configuration
          # Additional production-specific settings
          ENV_EOF

          # Create root-level .env file for docker-compose variable substitution
          cat > /tmp/deployment/.env << ENV_EOF
          # Docker Compose Environment Variables (Production)
          # Container registry configuration
          CONTAINER_REGISTRY=${{ steps.registry.outputs.registry }}
          REPOSITORY_OWNER=${{ steps.registry.outputs.repository_owner }}

          # Application versions
          BACKEND_VERSION=${{ steps.backend_version.outputs.version }}
          FRONTEND_VERSION=${{ steps.frontend_version.outputs.version }}

          # Full image paths with registry (using SHA-tagged images for immutability)
          BACKEND_IMAGE=${{ steps.registry.outputs.registry_path }}/backend:${{ steps.backend_version.outputs.version }}-${{ github.sha }}
          FRONTEND_IMAGE=${{ steps.registry.outputs.registry_path }}/frontend:${{ steps.frontend_version.outputs.version }}-${{ github.sha }}

          # Security configuration
          SECRET_KEY="${SECRET_KEY}"

          # Database configuration
          DB_NAME=backend_production_db
          DB_USER=backend_production_user
          DB_PASSWORD="${DB_PASSWORD}"

          # Redis configuration
          REDIS_PASSWORD="${REDIS_PASSWORD}"
          ENV_EOF

          # ================================================================
          # STEP 1: Clean Cache Volumes
          # ================================================================
          echo "#### Step 1: Cleaning cache volumes" >> $GITHUB_STEP_SUMMARY
          echo "Removing stale cache volumes to prevent serving outdated content..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            cd ${DEPLOY_DIR}

            echo '=== Cache Volume Cleanup ==='
            echo 'Removing cache-only volumes to prevent stale content:'
            echo ''

            # Remove nginx cache volumes (static and media file caches)
            # These can serve stale content after deployments if not cleared
            docker volume rm app-production_proxy_cache_static 2>/dev/null && echo '✅ Removed proxy_cache_static' || echo 'ℹ️  proxy_cache_static not found (first deployment or already clean)'
            docker volume rm app-production_proxy_cache_media 2>/dev/null && echo '✅ Removed proxy_cache_media' || echo 'ℹ️  proxy_cache_media not found (first deployment or already clean)'

            # Remove Redis data volume to flush all cache entries
            # This prevents old application state from persisting across deployments
            docker volume rm app-production_redis_data 2>/dev/null && echo '✅ Removed redis_data (cache will be rebuilt)' || echo 'ℹ️  redis_data not found (first deployment or already clean)'

            echo ''
            echo '=== Preserved Data Volumes ==='
            echo 'The following volumes are PRESERVED (user data):'
            echo '  - postgres_data (database - contains user data)'
            echo '  - backend_media (user uploads)'
            echo '  - backend_static (collected static files - will be regenerated)'
            echo '  - proxy_logs (nginx access/error logs for debugging)'
            echo ''
          " | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Cache volumes cleaned successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 2: Stop Existing Containers
          # ================================================================
          echo "#### Step 2: Stopping existing containers" >> $GITHUB_STEP_SUMMARY
          echo "Stopping any running containers to release file locks and ensure clean deployment..." >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && docker compose -f docker-compose.yml -f compose.production.yml down --remove-orphans 2>&1 || echo 'No existing containers to stop'" | tee -a $GITHUB_STEP_SUMMARY

          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "✅ Containers stopped successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 3: Create Deployment Directories
          # ================================================================
          echo "#### Step 3: Creating deployment directories" >> $GITHUB_STEP_SUMMARY
          echo "Ensuring all required directories exist on the server..." >> $GITHUB_STEP_SUMMARY

          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "mkdir -p ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx && echo 'Directories created: ${DEPLOY_DIR}/{backend,frontend,nginx}'"

          echo "✅ Directories created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 4: Transfer Configuration Files
          # ================================================================
          echo "#### Step 4: Transferring configuration files" >> $GITHUB_STEP_SUMMARY
          echo "Uploading Docker Compose files, nginx config, and environment files to server..." >> $GITHUB_STEP_SUMMARY

          # Ensure directories are writable and wait for file locks to be released
          echo "Verifying directory permissions and clearing file locks..." >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} "
            # Ensure deployment directory ownership is correct
            sudo chown -R ${SERVER_USER}:${SERVER_USER} ${DEPLOY_DIR} 2>/dev/null || true

            # Remove any read-only flags and ensure write permissions
            chmod -R u+w ${DEPLOY_DIR}/backend ${DEPLOY_DIR}/frontend ${DEPLOY_DIR}/nginx 2>/dev/null || true

            # Wait for file locks to be released after container shutdown
            sleep 5

            # Verify directories are writable
            if [ ! -w \"${DEPLOY_DIR}/nginx\" ]; then
              echo \"Warning: ${DEPLOY_DIR}/nginx is still not writable after permission fix\"
              ls -ld ${DEPLOY_DIR}/nginx
            fi
          "

          echo "Transferring compose files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            docker-compose.yml compose.production.yml \
            /tmp/deployment/.env \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/

          echo "Transferring nginx configuration..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            nginx/nginx.production.conf \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/nginx/nginx.production.conf

          echo "Transferring backend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/backend/.env.docker \
            /tmp/deployment/backend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/backend/

          echo "Transferring frontend environment files..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            /tmp/deployment/frontend/.env.docker \
            /tmp/deployment/frontend/.env.production \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/frontend/

          echo "Transferring deployment script..." >> $GITHUB_STEP_SUMMARY
          scp -i ~/.ssh/id_ed25519 \
            .github/scripts/deploy-production.sh \
            ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_DIR}/deploy-production.sh

          echo "✅ All configuration files transferred successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ================================================================
          # STEP 5: Execute Deployment Script on Server
          # ================================================================
          echo "#### Step 5: Executing deployment on server" >> $GITHUB_STEP_SUMMARY
          echo "Running deployment script with health monitoring..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Execute deployment script on server
          # Use single quotes to prevent variable expansion on the client side
          # and properly escape variables for the remote shell
          ssh -tt -i ~/.ssh/id_ed25519 ${SERVER_USER}@${SERVER_HOST} \
            "cd ${DEPLOY_DIR} && \
            REGISTRY='${REGISTRY}' \
            GITHUB_ACTOR='${GITHUB_ACTOR}' \
            GITHUB_TOKEN='${GITHUB_TOKEN}' \
            REDIS_PASSWORD='${REDIS_PASSWORD//\'/\'\\\'\'}' \
            bash deploy-production.sh"

          # Capture exit code from SSH session
          DEPLOY_EXIT_CODE=$?

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "✅ **Production deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All containers are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Production deployment encountered issues**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $DEPLOY_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployment script failed during execution. Review the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Containers failed health checks" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull failures" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration errors" >> $GITHUB_STEP_SUMMARY
            echo "- Resource constraints (disk space, memory)" >> $GITHUB_STEP_SUMMARY
            exit $DEPLOY_EXIT_CODE
          fi

      - name: Verify production deployment
        if: steps.deploy.outcome == 'success'
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "## Verifying Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check with retry logic and better error handling
          MAX_RETRIES=12
          RETRY_DELAY=5
          HEALTH_URL="http://${SERVER_HOST}/api/v1/status/"

          echo "Waiting for production environment to be ready..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking health endpoint..." >> $GITHUB_STEP_SUMMARY

            # Use status endpoint which always returns 200 and provides detailed info
            RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>&1)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            echo "HTTP Status: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY

            if [[ "$HTTP_CODE" == "200" ]]; then
              # Parse the status from JSON response
              STATUS=$(echo "$BODY" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

              if [[ "$STATUS" == "healthy" ]]; then
                echo "✅ Production environment is healthy" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "Response details:" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                echo "$BODY" | head -n 20 >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
                exit 0
              else
                echo "⚠️ Service responded but status is: $STATUS" >> $GITHUB_STEP_SUMMARY
                echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ Health endpoint returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${BODY:-}" ]]; then
                echo "Response: ${BODY}" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            if [[ $i -lt $MAX_RETRIES ]]; then
              echo "Waiting ${RETRY_DELAY}s before retry..." >> $GITHUB_STEP_SUMMARY
              sleep $RETRY_DELAY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "❌ Production environment health check failed after $MAX_RETRIES attempts" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Production deployment summary
        if: success()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Application successfully deployed to production**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # DIAGNOSTIC COLLECTION - PRODUCTION
  # ============================================================================
  # Collect comprehensive diagnostics if production deployment fails
  # ============================================================================

  collect-production-diagnostics:
    name: Collect Production Diagnostics
    needs: [deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'
    uses: ./.github/workflows/collect-deployment-diagnostics.yml
    with:
      environment: Production
      compose_file: compose.production.yml
    secrets:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  # ============================================================================
  # FAILURE DETECTION AND ISSUE CREATION
  # ============================================================================
  # Automatically detect workflow failures and create GitHub issues
  # Runs if any previous job fails
  # ============================================================================

  detect-workflow-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure() || cancelled()
    needs: [build-and-test, deploy-staging, e2e-testing, deploy-production]
    permissions:
      issues: write
      contents: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create failure tracking issue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "## Workflow Failure Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine which stage failed
          FAILED_STAGE="Unknown"
          if [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            FAILED_STAGE="Build and Test"
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Staging"
          elif [ "${{ needs.e2e-testing.result }}" = "failure" ]; then
            FAILED_STAGE="E2E Testing"
          elif [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            FAILED_STAGE="Deploy to Production"
          fi

          # Create issue title
          ISSUE_TITLE="CI/CD Pipeline Failed: $FAILED_STAGE - Run #${{ github.run_number }}"

          # Create issue body
          cat > /tmp/issue_body.md << EOF
          # CI/CD Pipeline Failure

          ## Failure Information

          - **Failed Stage**: $FAILED_STAGE
          - **Workflow**: Unified CI/CD Pipeline
          - **Run Number**: ${{ github.run_number }}
          - **Branch**: ${{ github.ref_name }}
          - **Commit**: ${{ github.sha }}
          - **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## Pipeline Status

          - Build and Test: ${{ needs.build-and-test.result }}
          - Deploy to Staging: ${{ needs.deploy-staging.result }}
          - E2E Testing: ${{ needs.e2e-testing.result }}
          - Deploy to Production: ${{ needs.deploy-production.result }}

          ## Next Steps

          1. Review the workflow logs at the run URL above
          2. Identify the root cause of the failure
          3. Fix the issue and commit with "Fix issue #N" to auto-close this issue

          ---

          Created by: Unified CI/CD Pipeline
          EOF

          # Create the issue with available labels
          # Note: Only use labels that exist in the repository
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md \
            --label "bug" || gh issue create \
            --title "$ISSUE_TITLE" \
            --body-file /tmp/issue_body.md)

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')

          echo "✅ Created issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
