# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# GitHub Actions Secrets Configuration
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#
# ⚠️  This file documents required secrets - it does NOT contain actual values.
# Configure actual secrets at: Repository Settings → Secrets and variables → Actions
#

# ============================================================================
# Required Secrets
# ============================================================================

# TARGET_REPO_PAT
# ---------------
# Purpose: Authenticate and push to EdenCoNz/proform repository
# Used by: .github/workflows/sync-to-proform.yml
#
# How to create:
#   1. GitHub Settings → Developer settings → Personal access tokens → Fine-grained tokens
#   2. Generate new token with:
#      - Repository access: Only EdenCoNz/proform
#      - Permissions: Contents (Read and write)
#   3. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: TARGET_REPO_PAT
#      - Value: <paste token>
#
# Recommended: Set 90-day expiration and create calendar reminder to rotate

# ============================================================================
# Deployment to Ubuntu Server (deploy-to-ubuntu.yml - Reusable Workflow)
# ============================================================================

# This reusable workflow deploys Docker containers to an Ubuntu server using
# Tailscale VPN for secure connectivity. It's called by frontend-ci.yml and
# backend-ci.yml workflows.

# TS_OAUTH_CLIENT_ID
# ------------------
# Purpose: Tailscale OAuth client ID for establishing VPN connection from GitHub Actions
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
#
# How to create:
#   1. Go to Tailscale Admin Console: https://login.tailscale.com/admin/settings/oauth
#   2. Generate OAuth Client:
#      - Click "Generate OAuth client"
#      - Description: "GitHub Actions CI/CD Deployment"
#      - Tags: "tag:ci" (create this tag in ACLs if needed)
#      - Scopes: devices:write
#   3. Copy the OAuth Client ID
#   4. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: TS_OAUTH_CLIENT_ID
#      - Value: <paste OAuth client ID>
#
# Security: OAuth clients can be revoked at any time from Tailscale admin console
# Recommended: Create a dedicated OAuth client for CI/CD, separate from other uses

# TS_OAUTH_SECRET
# ---------------
# Purpose: Tailscale OAuth client secret for establishing VPN connection from GitHub Actions
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
#
# How to create:
#   1. Created automatically when you generate the OAuth client (see TS_OAUTH_CLIENT_ID above)
#   2. Copy the OAuth Client Secret (shown only once during creation)
#   3. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: TS_OAUTH_SECRET
#      - Value: <paste OAuth client secret>
#
# Security: Store this secret immediately - it's shown only once
# If lost, regenerate the OAuth client and update both ID and secret
# Recommended: Rotate periodically (every 90 days)

# SSH_PRIVATE_KEY
# ---------------
# Purpose: SSH private key for authenticating to Ubuntu deployment server
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
# Format: ED25519 (recommended for security and performance)
#
# How to create:
#   1. Generate ED25519 key pair on your local machine:
#      ssh-keygen -t ed25519 -C "github-actions-deployment" -f ~/.ssh/github_deploy_ed25519
#
#   2. Copy the public key to your Ubuntu server:
#      ssh-copy-id -i ~/.ssh/github_deploy_ed25519.pub user@your-server
#      OR manually append to ~/.ssh/authorized_keys on the server:
#      cat ~/.ssh/github_deploy_ed25519.pub | ssh user@your-server "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
#
#   3. Copy the ENTIRE private key (including headers):
#      cat ~/.ssh/github_deploy_ed25519
#      # Should start with: -----BEGIN OPENSSH PRIVATE KEY-----
#      # Should end with: -----END OPENSSH PRIVATE KEY-----
#
#   4. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: SSH_PRIVATE_KEY
#      - Value: <paste entire private key including headers>
#
# Security Best Practices:
#   - Use a dedicated key pair for CI/CD (don't reuse personal keys)
#   - Set restrictive permissions on server: chmod 600 ~/.ssh/authorized_keys
#   - Consider IP restrictions in ~/.ssh/authorized_keys if possible
#   - Rotate keys periodically (every 6-12 months)
#   - Delete local private key after adding to GitHub Secrets
#
# Troubleshooting:
#   - Verify public key is in ~/.ssh/authorized_keys on server
#   - Check SSH service is running: sudo systemctl status sshd
#   - Verify server firewall allows SSH (port 22)

# SERVER_HOST
# -----------
# Purpose: Tailscale IP address of the Ubuntu deployment server
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
# Format: Tailscale IP (e.g., 100.x.x.x)
#
# How to find:
#   1. On your Ubuntu server, run: tailscale ip -4
#   2. Copy the IP address (should start with 100.)
#   3. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: SERVER_HOST
#      - Value: <paste Tailscale IP>
#
# Example: 100.101.102.103
#
# Note: Use Tailscale IP (100.x.x.x), NOT public IP or hostname
# This ensures secure communication over Tailscale VPN tunnel
#
# Verification:
#   - From another machine on Tailscale network: ping <tailscale-ip>
#   - Check server is online: tailscale status

# SERVER_USER
# -----------
# Purpose: SSH username for connecting to the Ubuntu deployment server
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
#
# How to determine:
#   1. Use the username that has SSH access to your Ubuntu server
#   2. This user must have:
#      - SSH access (public key in ~/.ssh/authorized_keys)
#      - Docker permissions (member of 'docker' group)
#      - Write access to deployment directory
#
#   3. Add to repository: Settings → Secrets and variables → Actions → New repository secret
#      - Name: SERVER_USER
#      - Value: <your SSH username>
#
# Example: ubuntu, deploy, admin, or your custom username
#
# Server Setup (run on Ubuntu server as root or with sudo):
#   # Add user to docker group (allows running docker without sudo)
#   sudo usermod -aG docker <username>
#
#   # Verify docker group membership
#   groups <username>
#
#   # Create deployment directory with proper permissions
#   sudo mkdir -p /opt/deployments
#   sudo chown <username>:<username> /opt/deployments
#
# Security:
#   - Use a dedicated deployment user (not root)
#   - Grant minimal required permissions
#   - Enable sudo only if absolutely necessary (use docker group instead)

# DEPLOYMENT_TOKEN (Optional)
# ---------------------------
# Purpose: Optional authentication token for additional deployment security
# Used by: .github/workflows/deploy-to-ubuntu.yml (reusable workflow)
# Status: Currently not required, reserved for future use
#
# This can be used for:
#   - Webhook authentication
#   - Deployment API authorization
#   - Custom deployment script authentication
#
# Implementation example (not currently used):
#   ssh user@server "DEPLOY_TOKEN=${{ secrets.DEPLOYMENT_TOKEN }} ./deploy.sh"

# ============================================================================
# Deployment Workflow Integration
# ============================================================================
#
# The deploy-to-ubuntu.yml reusable workflow is called from:
#   - .github/workflows/backend-ci.yml (for backend deployments)
#   - .github/workflows/frontend-ci.yml (for frontend deployments)
#
# Example usage in backend-ci.yml:
#
#   deploy:
#     name: Deploy to Production
#     uses: ./.github/workflows/deploy-to-ubuntu.yml
#     needs: [build-container-prod, security-scan-prod, test-container]
#     if: github.event_name == 'push' && github.ref == 'refs/heads/main'
#     with:
#       service_name: backend
#       docker_image_artifact: backend-prod-container-${{ github.sha }}
#       docker_image_file: backend-prod.tar
#       docker_compose_file: backend/docker-compose.production.yml
#       container_name: backend-app
#       image_name: backend-prod
#     secrets: inherit
#
# All deployment secrets are automatically passed via "secrets: inherit"
#
# ============================================================================

# ============================================================================
# Frontend CI/CD (frontend-ci.yml)
# ============================================================================

# GITHUB_TOKEN Permissions
# ------------------------
# The workflow uses the built-in GITHUB_TOKEN with the following permissions:
#
# - contents: read (checkout code, read repository)
# - pull-requests: write (post coverage reports to PRs)
# - checks: write (create check runs)
# - issues: write (auto-close issues on successful build via reusable workflow)
# - packages: write (publish container images to GitHub Container Registry)
# - security-events: write (upload security scan results - security-scan-dev and security-scan-prod jobs)
#
# Auto-Close Issue Feature:
# Issues created by workflow failures are automatically closed by the
# detect-workflow-failures.yml workflow when the same workflow succeeds later.
# This is handled automatically - no reusable workflow call needed.
#
# Container Registry Publishing:
# The workflow publishes validated container images to GitHub Container Registry (GHCR)
# at ghcr.io/<owner>/<repo>/frontend. Images are only published after passing all
# validation gates (functional tests, security scan, size optimization). Pull requests
# from forks are blocked from publishing for security. Authentication uses GITHUB_TOKEN
# automatically - no additional secrets required.
#
# Security Scanning Integration:
# -------------------------------
# The workflow performs Trivy security scans on both development and production containers
# (security-scan-dev and security-scan-prod jobs). Scan results are uploaded to GitHub's
# Security tab using the CodeQL action (github/codeql-action/upload-sarif@v3).
#
# SARIF Upload Behavior:
# - If GitHub Advanced Security is enabled: Results appear in Security > Code Scanning tab
# - If Advanced Security is unavailable: Upload gracefully fails with continue-on-error
# - Fallback: SARIF and JSON scan results are always stored as workflow artifacts
# - The workflow provides clear status messages indicating upload success or fallback mode
#
# Requirements for Security Tab Integration:
# - GitHub Advanced Security feature (for private repositories)
# - Code Scanning API access enabled in repository settings
# - security-events: write permission (already configured)
# - No organization-level security policies blocking the integration
#
# Alternative Access to Scan Results:
# - Download SARIF files from workflow artifacts: trivy-dev-scan-results-<sha>
# - Download JSON files from workflow artifacts: trivy-prod-scan-results-<sha>
# - View vulnerability summary in GitHub Step Summary for each workflow run

# Current Status: No additional secrets required
#
# The frontend CI/CD workflow runs using GITHUB_TOKEN for:
# - ESLint linting checks
# - Prettier formatting checks
# - TypeScript type checking
# - Production builds
# - Build artifact generation and upload
# - Security audit (npm audit)

# - Auto-closing issues on successful workflow runs (main branch only, via reusable workflow)
#
# Future Secrets (when implementing deployment):
# - Cloud provider credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.)
# - Deployment API tokens (NETLIFY_AUTH_TOKEN, VERCEL_TOKEN, etc.)
# - Environment-specific configuration secrets

# ============================================================================
# Detect Workflow Failures (detect-workflow-failures.yml)
# ============================================================================

# GITHUB_TOKEN Permissions
# ------------------------
# This workflow monitors Frontend CI/CD and Backend CI/CD workflows and:
#
# - contents: read (access repository contents and workflow files)
# - actions: read (read workflow run information via API)
# - issues: write (create issues for failures, close them on success)
#
# Workflow Behavior:
# ------------------
# On workflow failure (main branch only):
#   - Creates a single aggregated GitHub issue with all job/step failures
#   - Includes job/step names, job URLs, and metadata (runURL, runID, branch, commit)
#   - Labels issue with "workflow-failure" for easy tracking
#   - Follows markdown structure defined in docs/templates/issue-log-template.md
#
# On workflow success (main branch only):
#   - Automatically searches for open issues with "workflow-failure" label
#   - Finds issues matching the workflow name (e.g., "Frontend CI/CD")
#   - Closes all matching issues with a comment linking to the successful run
#   - Provides comprehensive summary in GitHub Step Summary
#
# This workflow has two jobs:
# 1. detect-failures: Runs when workflow fails/cancels, creates detailed issue
# 2. auto-close-issues: Runs when workflow succeeds, closes related failure issues
#
# Triggered by:
# - workflow_run event for "Frontend CI/CD" and "Backend CI/CD" workflows
# - Only monitors workflows on the default branch (main)
#
# Notes:
# - PR branch failures are handled inline by Frontend/Backend CI/CD workflows
# - This workflow provides detailed analysis for main branch failures only
# - Auto-close feature eliminates need for manual issue cleanup

# ============================================================================
# Backend CI/CD (backend-ci.yml)
# ============================================================================

# GITHUB_TOKEN Permissions
# ------------------------
# The workflow uses the built-in GITHUB_TOKEN with the following permissions:
#
# - contents: read (checkout code, read repository)
# - pull-requests: write (post coverage reports to PRs, auto-close PRs)
# - checks: write (create check runs)
# - issues: write (auto-close issues from commit messages, always runs regardless of CI status)
# - security-events: write (upload security scan results)

# Current Status: No additional secrets required
#
# The backend CI/CD workflow runs using GITHUB_TOKEN for:
# - Black formatting checks
# - isort import sorting checks
# - Flake8 linting
# - mypy type checking
# - pytest tests with coverage (unit, integration, e2e)
# - pip safety security scanning
# - Bandit security linting
# - Django build verification (collectstatic, check --deploy, migrations)
# - Auto-closing issues from commit messages (runs ALWAYS, even if CI fails)
#
# Auto-Close Issue Feature (Commit Message Based):
# Issues referenced in commit messages using the pattern 'fix issue #<number>' are
# automatically closed by the auto-close-issue-from-commit job. This job runs with
# if: always() to ensure it executes regardless of whether the CI workflow succeeds
# or fails. The feature supports:
# - Case-insensitive pattern matching (fix/Fix/fixes/fixed)
# - Multiple issue references in a single commit message
# - Different close messages based on CI status (success vs failure)
# - Validation that issues exist and are open before closing
# - Comprehensive GitHub Step Summary with closure status
#
# Pattern Examples:
# - "fix issue #123" → closes issue #123
# - "Fix issue #456" → closes issue #456
# - "fixes issue #789" → closes issue #789
# - "fixed issue #999 and fix issue #111" → closes both #999 and #111
#
# Services Used:
# - PostgreSQL 16 (service container for tests)
# - Redis 7 (service container for tests, cache/sessions)
#
# Environment Variables Required for CI/CD Jobs:
# ------------------------------------------------
# These environment variables are configured directly in the workflow file
# (backend-ci.yml) and do not require repository secrets.
#
# Type Checking (typecheck job):
# - SECRET_KEY: typecheck-secret-key-for-ci-validation-only
#   Purpose: Allow Django configuration validation during type checking
#   Note: This is a non-production value safe for CI/CD use only
# - DB_NAME: sqlite (dummy value for validation)
# - DEBUG: False (production-like type checking)
#
# Tests (test job):
# - DB_NAME: test_backend_db (provided by workflow)
# - DB_USER: test_user (provided by workflow)
# - DB_PASSWORD: test_password (provided by workflow)
# - DB_HOST: localhost (provided by workflow)
# - DB_PORT: 5432 (provided by workflow)
# - REDIS_URL: redis://localhost:6379/1 (provided by workflow)
# - SECRET_KEY: test-secret-key-for-ci-testing-only (provided by workflow)
# - DEBUG: False (provided by workflow)
#
# Build Verification (build job):
# - SECRET_KEY: build-verification-secret-key
# - DB_NAME: sqlite (dummy value for validation)
# - DEBUG: False (production-like checks)
#
# Container Functional Testing:
# - Uses service containers (PostgreSQL 16, Redis 7) for testing production container
# - Verifies container starts with database connectivity
# - Tests API endpoints accessibility and functionality
# - Validates health checks pass correctly
# - Runs in test-backend-prod-container job
# - No additional secrets required - uses test credentials only
#
# Future Secrets (when implementing deployment):
# - Cloud provider credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.)
# - Deployment API tokens (HEROKU_API_KEY, RAILWAY_TOKEN, etc.)
# - Production database credentials (if deploying migrations)
# - Environment-specific configuration secrets
# - SENTRY_DSN (for error tracking in production)
# - Email service credentials (SMTP settings)

# ============================================================================
# Unified CI/CD Pipeline - Container Registry Configuration
# ============================================================================

# Registry-Based Deployment Architecture
# ---------------------------------------
# The unified CI/CD workflow uses a container registry for image distribution:
#
# Build Phase:
# 1. Build backend and frontend production images
# 2. Push images to container registry (default: GHCR)
# 3. Tag images with version, SHA, latest, and branch name
#
# Deploy Phase:
# 1. Servers authenticate to registry
# 2. Pull latest images from registry
# 3. Start containers with pulled images
#
# Benefits:
# - No tar.gz export/transfer required
# - Faster deployments (parallel pulls)
# - Registry acts as single source of truth
# - Easy rollbacks to previous versions
# - Works with any registry (GHCR, Docker Hub, private)

# Default Registry Configuration
# -------------------------------
# Registry: ghcr.io (GitHub Container Registry)
# Registry Path: ghcr.io/<repository-owner>/
#
# Published Images:
# - Backend:  ghcr.io/<owner>/backend
# - Frontend: ghcr.io/<owner>/frontend
#
# Image Tags (per build):
# - <version> (e.g., 1.0.0) - semantic version
# - <version>-<sha> (e.g., 1.0.0-abc123) - version + commit
# - latest - latest successful build
# - <branch> (e.g., main) - branch-specific

# Configurable Registry (Optional)
# ---------------------------------
# To use a different registry:
#
# 1. Add repository variable:
#    Settings → Secrets and variables → Actions → Variables
#    Name: CONTAINER_REGISTRY
#    Value: docker.io (or your registry hostname)
#
# 2. Update authentication (if not GHCR):
#    - Add registry credentials as secrets
#    - Update docker/login-action in workflow
#
# Supported registries:
# - ghcr.io (default, uses GITHUB_TOKEN)
# - docker.io (Docker Hub)
# - registry.example.com (self-hosted)
# - Any OCI-compliant registry

# Authentication Configuration
# ----------------------------
# CI/CD Pipeline (automatic):
# - Uses GITHUB_TOKEN with packages:write permission
# - No additional secrets required for GHCR
# - Authentication step included in workflow
#
# Deployment Servers (staging/production):
# - Authenticate before pulling images
# - Command: echo "$GITHUB_TOKEN" | docker login ghcr.io -u <user> --password-stdin
# - Authentication included in deployment workflow
# - GITHUB_TOKEN passed securely via workflow
#
# Manual Server Deployments:
# - Create GitHub Personal Access Token (PAT)
# - Required scope: packages:read
# - Login: docker login ghcr.io -u <username> -p <PAT>
# - Store PAT securely, rotate periodically (90 days recommended)

# Registry Image Visibility
# --------------------------
# Default: Private (repository members only)
#
# To make images public:
# 1. Go to GitHub → Packages → Select package
# 2. Package settings → Change visibility → Public
# 3. Public images require no authentication to pull
#
# Security Considerations:
# - Keep production images private
# - Use PATs with minimal scopes
# - Rotate credentials regularly
# - Monitor package access logs
# - Enable two-factor authentication

# Required Permissions
# --------------------
# GITHUB_TOKEN permissions (already configured):
# - packages:write (CI/CD - push images to registry)
# - contents:read (CI/CD - checkout code)
#
# Deployment server permissions:
# - packages:read (pull images from registry)
# - Use PAT or GITHUB_TOKEN with appropriate scope

# Image Lifecycle Management
# ---------------------------
# - Images built on every push to main branch
# - Multiple tags per image for flexible referencing
# - Old images retained indefinitely (manual cleanup)
# - Configure retention policy in package settings
# - Delete unused tags to save storage
#
# Cleanup recommendations:
# - Keep latest 10 builds per branch
# - Delete feature branch images after merge
# - Retain production versions for 90 days minimum

# Troubleshooting
# ---------------
# Authentication failed:
# - Verify GITHUB_TOKEN has packages:read/write scope
# - Check registry hostname is correct (no protocol)
# - Ensure user has repository access
#
# Image pull failed:
# - Verify image exists: docker search ghcr.io/<owner>/<image>
# - Check image visibility (public vs private)
# - Ensure authentication succeeded
# - Verify network connectivity to registry
#
# Deployment timeout:
# - Large images may take time to pull
# - Check server internet bandwidth
# - Consider using image layer caching
# - Monitor server docker daemon logs
