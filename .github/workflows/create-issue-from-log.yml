name: Create Issue from Log

# Reusable workflow for creating tracking issues from failure log files
# This workflow can be triggered in two ways:
# 1. As a reusable workflow (workflow_call) for integration with other workflows
# 2. Via workflow_dispatch for independent execution per log file

on:
  workflow_call:
    inputs:
      log_filename:
        description: 'Path to the issue log file to process'
        required: true
        type: string
      run_id:
        description: 'Workflow run ID that triggered this issue creation (failed workflow)'
        required: true
        type: string
      artifact_run_id:
        description: 'Workflow run ID where the artifact was uploaded (detect-workflow-failures)'
        required: true
        type: string
      job_id:
        description: 'Job ID that failed'
        required: true
        type: string

  workflow_dispatch:
    inputs:
      log_filename:
        description: 'Path to the issue log file to process'
        required: true
        type: string
      run_id:
        description: 'Workflow run ID that triggered this issue creation (failed workflow)'
        required: true
        type: string
      artifact_run_id:
        description: 'Workflow run ID where the artifact was uploaded (detect-workflow-failures)'
        required: true
        type: string
      job_id:
        description: 'Job ID that failed'
        required: true
        type: string

# Minimal required permissions for issue creation workflow
# issues: write is required to create tracking issues
# actions: read is required to download artifacts from other workflow runs
permissions:
  contents: read
  issues: write
  actions: read

jobs:
  process-issue-log:
    name: Process Issue Log
    runs-on: ubuntu-22.04
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download issue log artifacts
        uses: actions/download-artifact@v4
        with:
          name: issue-logs
          path: issue-logs/
          run-id: ${{ inputs.artifact_run_id }}
          github-token: ${{ github.token }}

      - name: Verify log file exists
        id: verify-log
        run: |
          if [ ! -f "${{ inputs.log_filename }}" ]; then
            echo "Error: Log file not found: ${{ inputs.log_filename }}"
            exit 1
          fi

          echo "Log file verified: ${{ inputs.log_filename }}"
          echo "log_exists=true" >> $GITHUB_OUTPUT

      - name: Extract workflow execution metadata
        id: extract-metadata
        run: |
          RUN_ID="${{ inputs.run_id }}"
          JOB_ID="${{ inputs.job_id }}"

          echo "## Extracting Workflow Execution Metadata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "**Job ID**: $JOB_ID" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Fetch workflow run details
          RUN_JSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/$RUN_ID")

          # Extract run-level metadata
          RUN_URL=$(echo "$RUN_JSON" | jq -r '.html_url')
          WORKFLOW_NAME=$(echo "$RUN_JSON" | jq -r '.name')
          RUN_NUMBER=$(echo "$RUN_JSON" | jq -r '.run_number')
          HEAD_SHA=$(echo "$RUN_JSON" | jq -r '.head_sha')
          HEAD_BRANCH=$(echo "$RUN_JSON" | jq -r '.head_branch')

          # Construct commit URL
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/$HEAD_SHA"

          # Extract PR URL if available
          PR_NUMBER=$(echo "$RUN_JSON" | jq -r '.pull_requests[0].number // empty')
          if [ -n "$PR_NUMBER" ]; then
            PR_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          else
            PR_URL="N/A"
          fi

          # Fetch job details
          JOB_JSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/jobs/$JOB_ID")

          # Extract job-level metadata
          JOB_NAME=$(echo "$JOB_JSON" | jq -r '.name')
          JOB_URL=$(echo "$JOB_JSON" | jq -r '.html_url')
          JOB_STATUS=$(echo "$JOB_JSON" | jq -r '.status')
          JOB_CONCLUSION=$(echo "$JOB_JSON" | jq -r '.conclusion')
          JOB_STARTED_AT=$(echo "$JOB_JSON" | jq -r '.started_at')
          JOB_COMPLETED_AT=$(echo "$JOB_JSON" | jq -r '.completed_at')

          # Find the first failed step
          FAILED_STEP_NAME=$(echo "$JOB_JSON" | jq -r '.steps[] | select(.conclusion == "failure") | .name' | head -n 1)
          FAILED_STEP_NUMBER=$(echo "$JOB_JSON" | jq -r '.steps[] | select(.conclusion == "failure") | .number' | head -n 1)

          # If no failed step found, use job-level failure
          if [ -z "$FAILED_STEP_NAME" ]; then
            FAILED_STEP_NAME="Job-level failure"
            FAILED_STEP_NUMBER="0"
          fi

          # Extract log line numbers from failed step (if available)
          # GitHub doesn't provide direct line number access via API, but we can note this for future log extraction
          LOG_LINE_NUMBERS="See workflow run URL for complete logs"

          # Output all extracted metadata to GITHUB_OUTPUT for use in subsequent steps
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "run_url=$RUN_URL" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          echo "run_number=$RUN_NUMBER" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "head_branch=$HEAD_BRANCH" >> $GITHUB_OUTPUT
          echo "commit_url=$COMMIT_URL" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
          echo "job_name=$JOB_NAME" >> $GITHUB_OUTPUT
          echo "job_url=$JOB_URL" >> $GITHUB_OUTPUT
          echo "job_status=$JOB_STATUS" >> $GITHUB_OUTPUT
          echo "job_conclusion=$JOB_CONCLUSION" >> $GITHUB_OUTPUT
          echo "job_started_at=$JOB_STARTED_AT" >> $GITHUB_OUTPUT
          echo "job_completed_at=$JOB_COMPLETED_AT" >> $GITHUB_OUTPUT
          echo "step_name=$FAILED_STEP_NAME" >> $GITHUB_OUTPUT
          echo "step_number=$FAILED_STEP_NUMBER" >> $GITHUB_OUTPUT
          echo "log_line_numbers=$LOG_LINE_NUMBERS" >> $GITHUB_OUTPUT

          # Create summary of extracted metadata
          echo "### Extracted Metadata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Run Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Identifier**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Name**: $WORKFLOW_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Number**: $RUN_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "- **Run URL**: $RUN_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Job Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Job ID**: $JOB_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Job Name**: $JOB_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Job URL**: $JOB_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: $JOB_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Conclusion**: $JOB_CONCLUSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Started**: $JOB_STARTED_AT" >> $GITHUB_STEP_SUMMARY
          echo "- **Completed**: $JOB_COMPLETED_AT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Step Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Step Name**: $FAILED_STEP_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Step Number**: $FAILED_STEP_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Related Links" >> $GITHUB_STEP_SUMMARY
          echo "- **Pull Request**: $PR_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit URL**: $COMMIT_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run URL**: $RUN_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Extract log excerpt from failed step
        id: extract-logs
        run: |
          JOB_ID="${{ inputs.job_id }}"
          STEP_NUMBER="${{ steps.extract-metadata.outputs.step_number }}"

          echo "## Extracting Log Excerpt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Downloading logs for Job ID: $JOB_ID, Step: $STEP_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Download job logs
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/jobs/$JOB_ID/logs" > job_logs.txt || {
              echo "Warning: Could not download logs, will use placeholder text"
              echo "LOG_EXCERPT=Log excerpt unavailable. Please see workflow run URL for complete logs." >> $GITHUB_OUTPUT
              exit 0
            }

          # Find the failed step section in the logs
          # GitHub logs include timestamps and step markers
          # We'll extract approximately 20-30 lines before and after the failure indicators

          # Look for common failure patterns (error messages, exit codes, etc.)
          # Extract context around these failures
          if grep -qi "error\|failed\|exception\|fatal" job_logs.txt; then
            # Find the first error/failure line number
            FIRST_ERROR_LINE=$(grep -ni "error\|failed\|exception\|fatal" job_logs.txt | head -n 1 | cut -d: -f1)

            # Calculate range (30 lines before, 20 lines after)
            START_LINE=$((FIRST_ERROR_LINE - 30))
            if [ $START_LINE -lt 1 ]; then
              START_LINE=1
            fi
            END_LINE=$((FIRST_ERROR_LINE + 20))

            # Extract the excerpt
            LOG_EXCERPT=$(sed -n "${START_LINE},${END_LINE}p" job_logs.txt)

            echo "Extracted log excerpt from lines $START_LINE to $END_LINE (centered on line $FIRST_ERROR_LINE)" >> $GITHUB_STEP_SUMMARY
          else
            # If no clear error pattern, extract last 50 lines
            LOG_EXCERPT=$(tail -n 50 job_logs.txt)
            echo "No clear error pattern found, extracted last 50 lines of logs" >> $GITHUB_STEP_SUMMARY
          fi

          # Sanitize log excerpt to remove ANSI escape codes and other problematic characters
          # This prevents command injection and terminal escape sequence issues
          LOG_EXCERPT=$(printf '%s\n' "$LOG_EXCERPT" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/`/'"'"'/g')

          # Store excerpt in output (handle multiline with EOF delimiter)
          # Use printf to safely output LOG_EXCERPT without command substitution
          echo "log_excerpt<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$LOG_EXCERPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Add excerpt preview to summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Log Excerpt Preview (first 10 lines)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          printf '%s\n' "$LOG_EXCERPT" | head -n 10 >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Populate issue log template with metadata
        id: populate-template
        run: |
          LOG_FILE="${{ inputs.log_filename }}"

          # Extract metadata from previous step outputs
          WORKFLOW_NAME="${{ steps.extract-metadata.outputs.workflow_name }}"
          JOB_NAME="${{ steps.extract-metadata.outputs.job_name }}"
          STEP_NAME="${{ steps.extract-metadata.outputs.step_name }}"
          RUN_ID="${{ steps.extract-metadata.outputs.run_id }}"
          JOB_ID="${{ steps.extract-metadata.outputs.job_id }}"
          PR_URL="${{ steps.extract-metadata.outputs.pr_url }}"
          COMMIT_URL="${{ steps.extract-metadata.outputs.commit_url }}"
          RUN_URL="${{ steps.extract-metadata.outputs.run_url }}"
          LOG_LINE_NUMBERS="${{ steps.extract-metadata.outputs.log_line_numbers }}"
          LOG_EXCERPT="${{ steps.extract-logs.outputs.log_excerpt }}"

          # Generate issue title
          TITLE="Workflow Failure: $WORKFLOW_NAME - $JOB_NAME - $STEP_NAME"

          echo "## Populating Issue Log Template" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Template File**: \`$LOG_FILE\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create populated template using sed to replace empty fields
          # The template has the format: | field | value |
          # We need to replace the empty value cells with actual data

          cp "$LOG_FILE" "${LOG_FILE}.tmp"

          # Extract feature name from branch if it's a feature branch
          HEAD_BRANCH="${{ steps.extract-metadata.outputs.head_branch }}"
          if [[ "$HEAD_BRANCH" =~ ^feature/([0-9]+) ]]; then
            FEATURE_ID="${BASH_REMATCH[1]}"
            FEATURE_NAME="$HEAD_BRANCH"
          else
            FEATURE_ID="N/A (auto-detected failure)"
            FEATURE_NAME="N/A (auto-detected failure)"
          fi

          # Populate each field in the table
          # Using @ as sed delimiter to avoid conflicts with URLs containing /
          sed -i "s@| title |  |@| title | $TITLE |@" "${LOG_FILE}.tmp"
          sed -i "s@| featureID |  |@| featureID | $FEATURE_ID |@" "${LOG_FILE}.tmp"
          sed -i "s@| featureName |  |@| featureName | $FEATURE_NAME |@" "${LOG_FILE}.tmp"
          sed -i "s@| jobName |  |@| jobName | $JOB_NAME |@" "${LOG_FILE}.tmp"
          sed -i "s@| stepName |  |@| stepName | $STEP_NAME |@" "${LOG_FILE}.tmp"
          sed -i "s@| logLineNumbers |  |@| logLineNumbers | $LOG_LINE_NUMBERS |@" "${LOG_FILE}.tmp"
          sed -i "s@| PRURL |  |@| PRURL | $PR_URL |@" "${LOG_FILE}.tmp"
          sed -i "s@| commitURL |  |@| commitURL | $COMMIT_URL |@" "${LOG_FILE}.tmp"
          sed -i "s@| runURL |  |@| runURL | $RUN_URL |@" "${LOG_FILE}.tmp"

          # Append log excerpt to the template
          # The template has a section "## Failed Step Log Excerpt" followed by description
          # We'll append the actual log excerpt after that section
          # Use printf to safely output LOG_EXCERPT without command substitution
          echo "" >> "${LOG_FILE}.tmp"
          echo '```' >> "${LOG_FILE}.tmp"
          printf '%s\n' "$LOG_EXCERPT" >> "${LOG_FILE}.tmp"
          echo '```' >> "${LOG_FILE}.tmp"

          # Replace original log file with populated version
          mv "${LOG_FILE}.tmp" "$LOG_FILE"

          echo "**Status**: ✓ Template successfully populated with metadata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Verify no empty fields remain
          EMPTY_FIELDS=$(grep -c "|  |" "$LOG_FILE" || true)
          if [ "$EMPTY_FIELDS" -gt 0 ]; then
            echo "**Warning**: $EMPTY_FIELDS empty field(s) remain in template" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Validation**: ✓ All fields populated, no empty placeholders remain" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Check for duplicate issues
        id: check-duplicates
        run: |
          LOG_FILE="${{ inputs.log_filename }}"
          HEAD_BRANCH="${{ steps.extract-metadata.outputs.head_branch }}"

          echo "## Checking for Duplicate Issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: $HEAD_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Extract metadata from the populated log file
          TITLE=$(grep "^| title |" "$LOG_FILE" | sed 's/^| title | \(.*\) |$/\1/')
          FEATURE_ID=$(grep "^| featureID |" "$LOG_FILE" | sed 's/^| featureID | \(.*\) |$/\1/')
          FEATURE_NAME=$(grep "^| featureName |" "$LOG_FILE" | sed 's/^| featureName | \(.*\) |$/\1/')
          JOB_NAME=$(grep "^| jobName |" "$LOG_FILE" | sed 's/^| jobName | \(.*\) |$/\1/')
          STEP_NAME=$(grep "^| stepName |" "$LOG_FILE" | sed 's/^| stepName | \(.*\) |$/\1/')
          LOG_LINE_NUMBERS=$(grep "^| logLineNumbers |" "$LOG_FILE" | sed 's/^| logLineNumbers | \(.*\) |$/\1/')

          echo "### Current Issue Metadata" >> $GITHUB_STEP_SUMMARY
          echo "- **Title**: $TITLE" >> $GITHUB_STEP_SUMMARY
          echo "- **Feature ID**: $FEATURE_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Feature Name**: $FEATURE_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Job Name**: $JOB_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Step Name**: $STEP_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Log Line Numbers**: $LOG_LINE_NUMBERS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Query all open issues
          # We'll search for issues that might be duplicates based on the branch
          OPEN_ISSUES=$(gh issue list \
            --state open \
            --limit 100 \
            --json number,title,body)

          # Initialize duplicate detection flag
          DUPLICATE_FOUND=false
          DUPLICATE_ISSUE_NUMBER=""

          # Create Python script for duplicate detection
          cat > /tmp/check_duplicates.py << 'PYTHON_SCRIPT_EOF'
          import sys
          import json
          import re
          import os

          # Read the issues JSON from stdin
          issues = json.load(sys.stdin)

          # Extract current metadata from environment
          current_title = os.environ.get('CURRENT_TITLE', '')
          current_feature_id = os.environ.get('CURRENT_FEATURE_ID', '')
          current_feature_name = os.environ.get('CURRENT_FEATURE_NAME', '')
          current_job_name = os.environ.get('CURRENT_JOB_NAME', '')
          current_step_name = os.environ.get('CURRENT_STEP_NAME', '')
          current_log_line_numbers = os.environ.get('CURRENT_LOG_LINE_NUMBERS', '')

          # Function to extract field value from issue body
          def extract_field(body, field_name):
              if not body:
                  return None
              # Match: | fieldName | value |
              pattern = r'\|\s*' + re.escape(field_name) + r'\s*\|\s*(.+?)\s*\|'
              match = re.search(pattern, body, re.MULTILINE | re.IGNORECASE)
              if match:
                  value = match.group(1).strip()
                  return value if value else None
              return None

          duplicate_found = False
          duplicate_number = None

          # Check each issue for duplicates
          for issue in issues:
              issue_number = issue.get('number')
              issue_body = issue.get('body', '')

              # Extract all fields from the issue body
              issue_title = extract_field(issue_body, 'title')
              issue_feature_id = extract_field(issue_body, 'featureID')
              issue_feature_name = extract_field(issue_body, 'featureName')
              issue_job_name = extract_field(issue_body, 'jobName')
              issue_step_name = extract_field(issue_body, 'stepName')
              issue_log_line_numbers = extract_field(issue_body, 'logLineNumbers')

              # First check: must be from the same branch (feature name)
              if issue_feature_name != current_feature_name:
                  continue

              # Check if ALL required fields match
              all_match = (
                  issue_title == current_title and
                  issue_feature_id == current_feature_id and
                  issue_feature_name == current_feature_name and
                  issue_job_name == current_job_name and
                  issue_step_name == current_step_name and
                  issue_log_line_numbers == current_log_line_numbers
              )

              if all_match:
                  duplicate_found = True
                  duplicate_number = issue_number
                  print(f'DUPLICATE_MATCH=true', file=sys.stderr)
                  print(f'DUPLICATE_NUMBER={issue_number}', file=sys.stderr)
                  break

          # Output results
          if duplicate_found:
              print(f'Duplicate issue found: #{duplicate_number}')
              sys.exit(0)
          else:
              print('No duplicate issues found')
              sys.exit(1)
          PYTHON_SCRIPT_EOF

          # Run Python script with environment variables
          export CURRENT_TITLE="$TITLE"
          export CURRENT_FEATURE_ID="$FEATURE_ID"
          export CURRENT_FEATURE_NAME="$FEATURE_NAME"
          export CURRENT_JOB_NAME="$JOB_NAME"
          export CURRENT_STEP_NAME="$STEP_NAME"
          export CURRENT_LOG_LINE_NUMBERS="$LOG_LINE_NUMBERS"

          echo "$OPEN_ISSUES" | python3 /tmp/check_duplicates.py 2>&1 | tee /tmp/duplicate_check.log || {
            # Python script exits with 1 if no duplicate found, 0 if duplicate found
            if grep -q "No duplicate issues found" /tmp/duplicate_check.log; then
              echo "**Status**: ✓ No duplicate issues found, will create new issue" >> $GITHUB_STEP_SUMMARY
              echo "duplicate_found=false" >> $GITHUB_OUTPUT
              echo "create_issue=true" >> $GITHUB_OUTPUT
            else
              echo "**Error**: Failed to check for duplicates, will create new issue as fallback" >> $GITHUB_STEP_SUMMARY
              echo "duplicate_found=false" >> $GITHUB_OUTPUT
              echo "create_issue=true" >> $GITHUB_OUTPUT
            fi
            exit 0
          }

          # Parse the output from Python script
          if grep -q "DUPLICATE_MATCH=true" /tmp/duplicate_check.log; then
            DUPLICATE_FOUND=true
            DUPLICATE_ISSUE_NUMBER=$(grep "DUPLICATE_NUMBER=" /tmp/duplicate_check.log | sed 's/DUPLICATE_NUMBER=//')

            echo "**Status**: ⚠️ Duplicate issue found: #$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "duplicate_found=true" >> $GITHUB_OUTPUT
            echo "duplicate_issue_number=$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_OUTPUT
            echo "create_issue=false" >> $GITHUB_OUTPUT
          else
            echo "**Status**: ✓ No duplicate issues found, will create new issue" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "duplicate_found=false" >> $GITHUB_OUTPUT
            echo "create_issue=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Label duplicate issue
        if: steps.check-duplicates.outputs.duplicate_found == 'true'
        run: |
          DUPLICATE_ISSUE_NUMBER="${{ steps.check-duplicates.outputs.duplicate_issue_number }}"

          echo "## Labeling Duplicate Issue" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue**: #$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add the "attempted" label to the existing issue
          gh issue edit "$DUPLICATE_ISSUE_NUMBER" --add-label "attempted" || {
            echo "**Warning**: Failed to add 'attempted' label to issue #$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "The issue may not have the label, but it was identified as a duplicate." >> $GITHUB_STEP_SUMMARY
            exit 0
          }

          echo "**Status**: ✓ Successfully added 'attempted' label to issue #$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: https://github.com/${{ github.repository }}/issues/$DUPLICATE_ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create tracking issue
        id: create-issue
        if: steps.check-duplicates.outputs.create_issue == 'true'
        run: |
          LOG_FILE="${{ inputs.log_filename }}"

          # Extract title from populated template
          ISSUE_TITLE=$(grep "^| title |" "$LOG_FILE" | sed 's/^| title | \(.*\) |$/\1/')

          echo "## Creating Tracking Issue" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue Title**: $ISSUE_TITLE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Read the populated log file as the issue body
          ISSUE_BODY=$(cat "$LOG_FILE")

          # Create the issue using gh CLI
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY")

          echo "issue_url=$ISSUE_URL" >> $GITHUB_OUTPUT

          echo "**Status**: ✓ Issue created successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Extract issue number from URL
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          echo "**Issue Number**: #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Display issue creation summary
        if: always()
        run: |
          echo "## Issue Creation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if duplicate was found
          if [ "${{ steps.check-duplicates.outputs.duplicate_found }}" == "true" ]; then
            echo "⚠️ **Duplicate issue detected - no new issue created**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Existing Issue**: #${{ steps.check-duplicates.outputs.duplicate_issue_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Issue URL**: https://github.com/${{ github.repository }}/issues/${{ steps.check-duplicates.outputs.duplicate_issue_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Action Taken**: Added 'attempted' label to existing issue" >> $GITHUB_STEP_SUMMARY
            echo "- **Log File**: \`${{ inputs.log_filename }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Workflow Run**: ${{ steps.extract-metadata.outputs.run_url }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> This failure appears to be the same as an existing open issue." >> $GITHUB_STEP_SUMMARY
            echo "> The existing issue has been labeled with 'attempted' to indicate another occurrence." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.create-issue.outcome }}" == "success" ]; then
            echo "✓ **Tracking issue created successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Issue URL**: ${{ steps.create-issue.outputs.issue_url }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Issue Number**: #${{ steps.create-issue.outputs.issue_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Log File**: \`${{ inputs.log_filename }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Workflow Run**: ${{ steps.extract-metadata.outputs.run_url }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.create-issue.outcome }}" == "skipped" ]; then
            echo "ℹ️ **Issue creation skipped**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Issue creation was skipped (likely due to duplicate detection)" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Issue creation failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for error details." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
