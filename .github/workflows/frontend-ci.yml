name: Frontend CI/CD

# Trigger on pull requests and pushes to main branch
on:
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual triggering

# Explicit permissions (least privilege)
permissions:
  contents: write  # Needed for log-bugs job to commit changes
  pull-requests: write
  checks: write
  actions: read  # Needed to fetch job logs and job information

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ========================================================================
  # TESTING MODE: All jobs disabled except log-bugs
  # To re-enable: uncomment the jobs below and restore the original log-bugs configuration
  # ========================================================================

  # # Job 1: Lint and Format Check
  # lint:
  #   name: Lint and Format Check
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 10
  #
  #   defaults:
  #     run:
  #       working-directory: ./frontend
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Install dependencies
  #       run: npm ci
  #
  #     - name: Run ESLint
  #       run: npm run lint
  #
  #     - name: Check Prettier formatting
  #       run: npm run format:check

  # # Job 2: Type Check
  # typecheck:
  #   name: TypeScript Type Check
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 10
  #
  #   defaults:
  #     run:
  #       working-directory: ./frontend
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Install dependencies
  #       run: npm ci
  #
  #     - name: Run TypeScript type check
  #       run: npx tsc -b --noEmit

  # # Job 3: Build
  # build:
  #   name: Build Application
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 15
  #   needs: [lint, typecheck]  # Only build if lint and typecheck pass
  #
  #   defaults:
  #     run:
  #       working-directory: ./frontend
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Install dependencies
  #       run: npm ci
  #
  #     - name: Build application
  #       run: npm run build
  #       env:
  #         NODE_ENV: production
  #
  #     - name: Upload build artifacts
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: frontend-build-${{ github.sha }}
  #         path: frontend/dist/
  #         retention-days: 7
  #         if-no-files-found: error
  #
  #     - name: Check build size
  #       run: |
  #         echo "## Build Statistics" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### Bundle Size" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         du -sh dist/ >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### File Breakdown" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         find dist -name "*.js" -o -name "*.css" | xargs du -h | sort -rh | head -10 >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # # Job 4: Security Audit
  # security:
  #   name: Security Audit
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 10
  #
  #   defaults:
  #     run:
  #       working-directory: ./frontend
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Install dependencies
  #       run: npm ci
  #
  #     - name: Run npm audit
  #       run: npm audit --audit-level=moderate
  #       continue-on-error: true  # Don't fail build on audit issues, but report them
  #
  #     - name: Security audit summary
  #       if: always()
  #       run: |
  #         echo "## Security Audit Results" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         npm audit --audit-level=moderate || echo "Security vulnerabilities detected - review above" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # # Job 5: Docker Build and Test
  # docker:
  #   name: Build and Test Docker Image
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 20
  #   needs: [build]  # Run after build job succeeds
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3
  #
  #     - name: Build Docker image
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: ./frontend
  #         file: ./frontend/Dockerfile
  #         push: false
  #         load: true
  #         tags: |
  #           frontend:${{ github.sha }}
  #           frontend:latest
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max
  #
  #     - name: Start container for testing
  #       run: |
  #         echo "Starting Docker container for health check testing..."
  #         docker run -d --name frontend-test -p 8080:8080 frontend:${{ github.sha }}
  #
  #         echo "Waiting for container to be ready..."
  #         sleep 5
  #
  #         echo "Container status:"
  #         docker ps -a --filter name=frontend-test
  #
  #     - name: Test health endpoint
  #       run: |
  #         echo "Testing health endpoint..."
  #
  #         # Wait up to 30 seconds for health endpoint to respond
  #         max_attempts=30
  #         attempt=0
  #
  #         while [ $attempt -lt $max_attempts ]; do
  #           if curl -f http://localhost:8080/health; then
  #             echo "✅ Health check passed!"
  #             echo ""
  #             echo "Health endpoint response:"
  #             curl -s http://localhost:8080/health
  #             exit 0
  #           fi
  #
  #           echo "Attempt $((attempt + 1))/$max_attempts - waiting for health endpoint..."
  #           sleep 1
  #           attempt=$((attempt + 1))
  #         done
  #
  #         echo "❌ Health check failed after $max_attempts attempts"
  #         echo ""
  #         echo "Container logs:"
  #         docker logs frontend-test
  #         exit 1
  #
  #     - name: Test application root
  #       run: |
  #         echo "Testing application root endpoint..."
  #
  #         if curl -f -s http://localhost:8080/ | grep -q "<!DOCTYPE html>"; then
  #           echo "✅ Application root responds with HTML"
  #         else
  #           echo "❌ Application root did not respond with valid HTML"
  #           docker logs frontend-test
  #           exit 1
  #         fi
  #
  #     - name: Container logs on failure
  #       if: failure()
  #       run: |
  #         echo "## Docker Container Failure Logs" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         docker logs frontend-test >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Could not retrieve logs" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #
  #     - name: Stop and remove test container
  #       if: always()
  #       run: |
  #         docker stop frontend-test || true
  #         docker rm frontend-test || true
  #
  #     - name: Docker build summary
  #       if: success()
  #       run: |
  #         echo "## Docker Build Success" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Docker image built successfully" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Image tagged with commit SHA: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Image tagged with: \`latest\`" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Container health check passed" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Application serves HTML correctly" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### Image Details" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         docker images frontend:${{ github.sha }} >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### Image Size" >> $GITHUB_STEP_SUMMARY
  #         docker images frontend:${{ github.sha }} --format "{{.Size}}" >> $GITHUB_STEP_SUMMARY

  # # Job 6: Deployment Readiness (only on main branch)
  # deployment-check:
  #   name: Deployment Readiness Check
  #   runs-on: ubuntu-22.04
  #   timeout-minutes: 5
  #   needs: [lint, typecheck, build, security, docker]
  #   if: github.ref == 'refs/heads/main' && github.event_name == 'push'
  #
  #   steps:
  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: frontend-build-${{ github.sha }}
  #         path: dist/
  #
  #     - name: Verify build artifacts
  #       run: |
  #         echo "## Deployment Readiness" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ All checks passed" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Build artifacts generated successfully" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Docker image built and tested successfully" >> $GITHUB_STEP_SUMMARY
  #         echo "✅ Ready for deployment" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### Artifact Contents" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         ls -lah dist/ >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #
  #     - name: Check index.html exists
  #       run: |
  #         if [ ! -f "dist/index.html" ]; then
  #           echo "❌ Error: index.html not found in build artifacts"
  #           exit 1
  #         fi
  #         echo "✅ index.html exists in build artifacts"

  # ========================================================================
  # Test Job: Intentional Failure (TESTING MODE)
  # This job always fails to trigger the log-bugs job
  # ========================================================================
  test-failure:
    name: Test Failure Job
    runs-on: ubuntu-22.04
    timeout-minutes: 5

    steps:
      - name: Simulate test failure
        run: |
          echo "This job is designed to always fail to test the log-bugs workflow"
          echo "Simulating test failure..."
          exit 1

  # ========================================================================
  # Job 7: Log bugs to JSON file (ACTIVE FOR TESTING)
  # ========================================================================
  log-bugs:
    name: Log Bug Report (Testing Mode)
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    needs: [test-failure]
    # TESTING: Runs when test-failure job fails
    # Original configuration:
    #   needs: [lint, typecheck, build, security, docker]
    #   if: |
    #     failure() &&
    #     github.event_name == 'pull_request' &&
    #     startsWith(github.head_ref, 'feature/')
    # Current testing configuration: runs when test-failure fails
    if: |
      failure() &&
      github.event_name == 'pull_request' &&
      startsWith(github.head_ref, 'feature/')

    permissions:
      contents: write  # Required: commit bug reports to repository and update bug-log.json
      actions: read    # Required: fetch job information and logs via GitHub Actions API

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract feature ID from branch name
        id: feature
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "Branch name: $BRANCH_NAME"

          # Extract feature ID from branch name (format: feature/{id})
          if [[ $BRANCH_NAME =~ ^feature/([0-9]+) ]]; then
            FEATURE_ID="${BASH_REMATCH[1]}"
            echo "Extracted feature ID: $FEATURE_ID"
            echo "feature_id=$FEATURE_ID" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            echo "❌ Error: Could not extract feature ID from branch name: $BRANCH_NAME"
            exit 1
          fi

      - name: Determine which job failed
        id: failed-job
        run: |
          # Check which job failed and set appropriate title
          if [ "${{ needs.test-failure.result }}" == "failure" ]; then
            echo "title=Test failure job failed - simulated test failure" >> $GITHUB_OUTPUT
            echo "failed_job=test-failure" >> $GITHUB_OUTPUT
          else
            # Fallback for testing
            echo "title=Unknown job failure" >> $GITHUB_OUTPUT
            echo "failed_job=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Create or update bug log entry
        run: |
          BUG_FILE="docs/features/bug-log.json"
          FEATURE_ID="${{ steps.feature.outputs.feature_id }}"
          BRANCH_NAME="${{ steps.feature.outputs.branch_name }}"
          TITLE="${{ steps.failed-job.outputs.title }}"
          FAILED_JOB="${{ steps.failed-job.outputs.failed_job }}"
          TODAY=$(date +%Y-%m-%d)
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          COMMIT_SHA="${{ github.sha }}"

          echo "Creating bug entry:"
          echo "  Feature ID: $FEATURE_ID"
          echo "  Branch: $BRANCH_NAME"
          echo "  Title: $TITLE"
          echo "  Date: $TODAY"

          # Ensure jq is installed
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Create bug-log.json if it doesn't exist
          if [ ! -f "$BUG_FILE" ]; then
            echo "Bug log file not found, creating new file: $BUG_FILE"
            mkdir -p "$(dirname "$BUG_FILE")"
            echo '{"bugs":[]}' > "$BUG_FILE"
          fi

          # Get the next bug ID (max bugID + 1, or 1 if no bugs exist)
          NEXT_BUG_ID=$(jq '[.bugs[].bugID] | if length > 0 then max + 1 else 1 end' "$BUG_FILE")
          echo "Next bug ID: $NEXT_BUG_ID"

          # Create new bug entry
          NEW_BUG=$(jq -n \
            --arg bugID "$NEXT_BUG_ID" \
            --arg featureID "$FEATURE_ID" \
            --arg featureName "$BRANCH_NAME" \
            --arg title "$TITLE" \
            --arg reportedDate "$TODAY" \
            '{
              bugID: ($bugID | tonumber),
              featureID: ($featureID | tonumber),
              featureName: $featureName,
              title: $title,
              reportedDate: $reportedDate,
              isFixed: false,
              fixedDate: null
            }')

          # Append new bug to the bugs array
          jq --argjson newBug "$NEW_BUG" '.bugs += [$newBug]' "$BUG_FILE" > "${BUG_FILE}.tmp"
          mv "${BUG_FILE}.tmp" "$BUG_FILE"

          echo "✅ Bug entry added successfully"
          echo ""
          echo "Updated bug log:"
          cat "$BUG_FILE"

          # Export variables for next steps
          echo "NEXT_BUG_ID=$NEXT_BUG_ID" >> $GITHUB_ENV
          echo "WORKFLOW_URL=$WORKFLOW_URL" >> $GITHUB_ENV
          echo "FAILED_JOB=$FAILED_JOB" >> $GITHUB_ENV

      - name: Fetch failed job logs
        id: fetch-logs
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          FAILED_JOB="${{ steps.failed-job.outputs.failed_job }}"
          RUN_ID="${{ github.run_id }}"
          REPO="${{ github.repository }}"

          echo "=========================================="
          echo "Fetching logs for failed job: $FAILED_JOB"
          echo "Run ID: $RUN_ID"
          echo "Repository: $REPO"
          echo "=========================================="
          echo ""

          # Initialize status tracking variables
          LOG_FETCH_STATUS="success"
          ERROR_DETAILS=""

          # ==========================================
          # STEP 1: Fetch jobs list from workflow run
          # ==========================================
          echo "Step 1: Fetching jobs list from workflow run..."
          JOBS_RESPONSE=$(mktemp)

          if ! gh api "/repos/$REPO/actions/runs/$RUN_ID/jobs" > "$JOBS_RESPONSE" 2>&1; then
            LOG_FETCH_STATUS="api_permission_error"
            ERROR_DETAILS="GitHub Actions API returned an error when attempting to fetch jobs list. This typically indicates insufficient permissions."

            echo "❌ API Error: Unable to fetch jobs list"
            echo "   Cause: API request to /repos/$REPO/actions/runs/$RUN_ID/jobs failed"
            echo "   Likely Issue: Insufficient 'actions=read' permission"
            echo "   Resolution: Ensure the workflow has 'actions=read' permission at job level"
            echo ""
            echo "failed_step=API Permission Error (Jobs List)" >> $GITHUB_OUTPUT
            echo "log_fetch_status=api_permission_error" >> $GITHUB_OUTPUT

            # Create fallback log entry with actionable information
            cat > job_logs.txt <<'FALLBACK_EOF'
=== LOG FETCH FAILED: API PERMISSION ERROR ===

Error Type: API Permission Denied (Jobs List Endpoint)
Endpoint: /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
Required Permission: actions=read

TROUBLESHOOTING STEPS:
1. Verify the workflow has 'actions=read' permission at the job level
2. Check if job-level permissions override workflow-level permissions
3. Review GitHub Actions token permissions in workflow YAML
4. Ensure the GITHUB_TOKEN has not been restricted by organization policies

RECOMMENDED FIX:
Add 'actions=read' to the job's permissions block in YAML format:
  permissions:
    contents=write
    actions=read

For more information, see:
https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication
FALLBACK_EOF

            rm -f "$JOBS_RESPONSE"
            exit 0
          fi

          # ==========================================
          # STEP 2: Validate API response structure
          # ==========================================
          echo "Step 2: Validating API response..."

          # Check if response is valid JSON
          if ! jq empty "$JOBS_RESPONSE" 2>/dev/null; then
            LOG_FETCH_STATUS="api_invalid_json"
            ERROR_DETAILS="GitHub Actions API returned non-JSON response. The response may contain an error message or the API may be experiencing issues."

            echo "❌ API Error: Invalid JSON response"
            echo "   Cause: Response from GitHub API is not valid JSON"
            echo "   Likely Issue: API error message or service disruption"
            echo "   Resolution: Check GitHub Status (https://www.githubstatus.com) and retry"
            echo ""
            echo "failed_step=API Error (Invalid JSON Response)" >> $GITHUB_OUTPUT
            echo "log_fetch_status=api_invalid_json" >> $GITHUB_OUTPUT

            cat > job_logs.txt <<'FALLBACK_EOF'
=== LOG FETCH FAILED: INVALID API RESPONSE ===

Error Type: Non-JSON API Response
Endpoint: /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

The GitHub Actions API returned a response that could not be parsed as JSON.
This may indicate:
- API service disruption
- Malformed request
- Network issues
- GitHub platform incident

TROUBLESHOOTING STEPS:
1. Check GitHub Status: https://www.githubstatus.com
2. Retry the workflow run
3. Review network connectivity
4. Check for GitHub API rate limiting

If the issue persists, contact GitHub Support.
FALLBACK_EOF

            rm -f "$JOBS_RESPONSE"
            exit 0
          fi

          # Check if response contains expected 'jobs' array
          if ! jq -e '.jobs' "$JOBS_RESPONSE" > /dev/null 2>&1; then
            LOG_FETCH_STATUS="api_missing_jobs_array"
            ERROR_DETAILS="GitHub Actions API response does not contain the expected 'jobs' array. This may indicate an API schema change or error response."

            echo "❌ API Error: Missing 'jobs' array in response"
            echo "   Cause: API response structure is not as expected"
            echo "   Likely Issue: API returned error object instead of jobs list"
            echo ""

            # Try to extract error message from response if available
            ERROR_MSG=$(jq -r '.message // "No error message provided"' "$JOBS_RESPONSE" 2>/dev/null)
            echo "   API Message: $ERROR_MSG"
            echo ""
            echo "failed_step=API Error (Missing Jobs Array)" >> $GITHUB_OUTPUT
            echo "log_fetch_status=api_missing_jobs_array" >> $GITHUB_OUTPUT

            cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: UNEXPECTED API RESPONSE ===

Error Type: Missing 'jobs' Array in API Response
Endpoint: /repos/$REPO/actions/runs/$RUN_ID/jobs

The API response did not contain the expected 'jobs' array field.

API Error Message: $ERROR_MSG

TROUBLESHOOTING STEPS:
1. Verify the workflow run ID is correct: $RUN_ID
2. Check if the workflow run still exists in GitHub UI
3. Ensure API permissions are configured correctly
4. Review GitHub Actions API documentation for schema changes

For API documentation, see:
https://docs.github.com/en/rest/actions/workflow-runs
FALLBACK_EOF

            rm -f "$JOBS_RESPONSE"
            exit 0
          fi

          # Validate jobs array is not empty
          JOB_COUNT=$(jq '.jobs | length' "$JOBS_RESPONSE" 2>/dev/null || echo "0")
          if [ "$JOB_COUNT" -eq 0 ]; then
            LOG_FETCH_STATUS="no_jobs_found"
            ERROR_DETAILS="The workflow run exists but contains no jobs in the API response."

            echo "⚠️  Warning: Jobs array is empty"
            echo "   Cause: No jobs found in workflow run"
            echo "   Possible Reason: Workflow run may still be initializing"
            echo ""
            echo "failed_step=Unknown (No Jobs in Run)" >> $GITHUB_OUTPUT
            echo "log_fetch_status=no_jobs_found" >> $GITHUB_OUTPUT

            cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: NO JOBS IN WORKFLOW RUN ===

Error Type: Empty Jobs Array
Run ID: $RUN_ID

The workflow run exists but contains no jobs. This may occur if:
- The workflow is still initializing
- The workflow was cancelled before jobs started
- There was an error in workflow configuration

TROUBLESHOOTING STEPS:
1. Check the workflow run in GitHub UI: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID
2. Verify workflow syntax is correct
3. Check for workflow configuration errors
4. Retry the workflow run
FALLBACK_EOF

            rm -f "$JOBS_RESPONSE"
            exit 0
          fi

          echo "✅ API response validated successfully"
          echo "   Jobs found: $JOB_COUNT"
          echo ""

          # ==========================================
          # STEP 3: Extract job ID for failed job
          # ==========================================
          echo "Step 3: Extracting job ID for failed job..."

          JOB_ID=$(jq -r ".jobs[] | select(.name == \"$FAILED_JOB\") | .id" "$JOBS_RESPONSE" 2>/dev/null || echo "")
          rm -f "$JOBS_RESPONSE"

          if [ -z "$JOB_ID" ]; then
            LOG_FETCH_STATUS="job_not_found"
            ERROR_DETAILS="Could not find job '$FAILED_JOB' in the workflow run. The job name may not match or the job may not have started yet."

            echo "❌ Error: Job not found in workflow run"
            echo "   Looking for: $FAILED_JOB"
            echo "   Possible Cause: Job name mismatch or job not started"
            echo "   Resolution: Verify job name matches the workflow configuration"
            echo ""
            echo "failed_step=Unknown (Job Not Found)" >> $GITHUB_OUTPUT
            echo "log_fetch_status=job_not_found" >> $GITHUB_OUTPUT

            cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: JOB NOT FOUND ===

Error Type: Job Name Not Found in Workflow Run
Job Name: $FAILED_JOB
Run ID: $RUN_ID

The specified job name was not found in the workflow run. This may occur if:
- The job name in the workflow file doesn't match the expected name
- The job was skipped due to conditional logic (if:)
- The job has not started yet
- There was a typo in the job name

TROUBLESHOOTING STEPS:
1. Verify the job name in .github/workflows/frontend-ci.yml matches: $FAILED_JOB
2. Check if the job has conditional logic that may have skipped it
3. Review the workflow run in GitHub UI to see which jobs actually executed
4. Ensure the job was not renamed recently

Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID
FALLBACK_EOF

            exit 0
          fi

          echo "✅ Job ID found: $JOB_ID"
          echo ""

          # ==========================================
          # STEP 4: Fetch failed step details
          # ==========================================
          echo "Step 4: Fetching failed step details..."

          STEP_RESPONSE=$(mktemp)
          if ! gh api "/repos/$REPO/actions/runs/$RUN_ID/jobs" > "$STEP_RESPONSE" 2>&1; then
            echo "⚠️  Warning: Could not fetch step details (using fallback)"
            FAILED_STEP="Unknown (API Error)"
            rm -f "$STEP_RESPONSE"
          else
            # Validate response is valid JSON
            if ! jq -e '.jobs' "$STEP_RESPONSE" > /dev/null 2>&1; then
              echo "⚠️  Warning: Invalid API response for step details (using fallback)"
              FAILED_STEP="Unknown (Invalid API Response)"
              rm -f "$STEP_RESPONSE"
            else
              # Extract failed step from valid response
              FAILED_STEP=$(jq -r ".jobs[] | select(.id == $JOB_ID) | .steps[] | select(.conclusion == \"failure\") | .name" "$STEP_RESPONSE" 2>/dev/null | head -n 1)
              rm -f "$STEP_RESPONSE"

              if [ -z "$FAILED_STEP" ]; then
                echo "⚠️  Warning: No failed step found (job may have failed during setup)"
                FAILED_STEP="Job Setup or Initialization"
              else
                echo "✅ Failed step identified: $FAILED_STEP"
              fi
            fi
          fi
          echo ""

          # Sanitize output to prevent bash injection
          SAFE_FAILED_STEP=$(echo "$FAILED_STEP" | tr -cd '[:alnum:] _-()' | head -c 200)
          echo "failed_step=$SAFE_FAILED_STEP" >> $GITHUB_OUTPUT
          echo "log_fetch_status=$LOG_FETCH_STATUS" >> $GITHUB_OUTPUT

          # ==========================================
          # STEP 5: Download job logs
          # ==========================================
          echo "Step 5: Downloading job logs..."

          LOGS_RESPONSE=$(mktemp)
          if gh api "/repos/$REPO/actions/jobs/$JOB_ID/logs" > "$LOGS_RESPONSE" 2>&1; then
            # Validate the response looks like logs (not JSON error)
            if head -n 1 "$LOGS_RESPONSE" 2>/dev/null | grep -q "^{"; then
              LOG_FETCH_STATUS="logs_permission_error"

              echo "❌ API Error: Received JSON error instead of logs"
              echo "   Cause: API returned error response when fetching logs"
              echo "   Likely Issue: Insufficient permissions or logs not yet available"
              echo ""

              # Try to extract error message
              ERROR_MSG=$(jq -r '.message // "No error message"' "$LOGS_RESPONSE" 2>/dev/null)
              echo "   API Message: $ERROR_MSG"
              echo ""

              cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: LOGS API PERMISSION ERROR ===

Error Type: API Permission Denied (Job Logs Endpoint)
Endpoint: /repos/$REPO/actions/jobs/$JOB_ID/logs
Required Permission: actions=read

API Error Message: $ERROR_MSG

The GitHub Actions API returned an error when attempting to fetch job logs.
This typically indicates:
- Insufficient 'actions=read' permission
- Logs are not yet available (job still running)
- Logs have been purged (older workflow runs)

TROUBLESHOOTING STEPS:
1. Verify 'actions=read' permission is set at job level
2. Wait for job completion before fetching logs
3. Check if logs are available in GitHub UI
4. For older runs, logs may have been purged per retention policy

Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID
FALLBACK_EOF

              rm -f "$LOGS_RESPONSE"
            else
              # Validate logs contain actual content
              LOG_SIZE=$(wc -c < "$LOGS_RESPONSE" 2>/dev/null || echo "0")
              if [ "$LOG_SIZE" -eq 0 ]; then
                LOG_FETCH_STATUS="logs_empty"

                echo "⚠️  Warning: Downloaded logs are empty"
                echo "   Cause: Log file has no content"
                echo "   Possible Reason: Job failed before producing output"
                echo ""

                cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH WARNING: EMPTY LOGS ===

The job logs were successfully fetched but contain no content.
This may occur if:
- The job failed during initialization before any output was produced
- The job was cancelled immediately
- There was an issue with log collection

Job ID: $JOB_ID
Failed Step: $FAILED_STEP

For more details, view the workflow run in GitHub UI:
${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID
FALLBACK_EOF

                rm -f "$LOGS_RESPONSE"
              else
                # Successfully downloaded logs
                mv "$LOGS_RESPONSE" job_logs.txt
                LOG_LINES=$(wc -l < job_logs.txt 2>/dev/null || echo "0")

                echo "✅ Successfully downloaded job logs"
                echo "   Log size: $LOG_SIZE bytes"
                echo "   Log lines: $LOG_LINES"
                echo "   Status: Complete"
                echo ""
              fi
            fi
          else
            # Primary log fetch failed, try fallback method
            LOG_FETCH_STATUS="logs_api_error"

            echo "⚠️  Warning: Could not download full logs via API"
            echo "   Attempting fallback: Extracting step summary from job details..."
            echo ""

            # Get step information from job details API as fallback
            FALLBACK_RESPONSE=$(mktemp)
            if gh api "/repos/$REPO/actions/runs/$RUN_ID/jobs" > "$FALLBACK_RESPONSE" 2>&1; then
              # Validate response is valid JSON
              if jq -e '.jobs' "$FALLBACK_RESPONSE" > /dev/null 2>&1; then
                # Extract step details for failed steps
                STEP_SUMMARY=$(jq -r ".jobs[] | select(.id == $JOB_ID) | .steps[] | select(.conclusion == \"failure\" or .conclusion == \"cancelled\") | \"\\n=== STEP: \(.name) ===\\nStatus: \(.conclusion)\\nStarted: \(.started_at)\\nCompleted: \(.completed_at)\\nNumber: \(.number)\\n\"" "$FALLBACK_RESPONSE" 2>/dev/null)

                if [ -n "$STEP_SUMMARY" ]; then
                  echo "✅ Fallback successful: Extracted step summary"

                  cat > job_logs.txt <<FALLBACK_EOF
=== FALLBACK LOG SUMMARY ===

Full job logs could not be retrieved via API. Below is a summary extracted from job metadata.

Job ID: $JOB_ID
Job Name: $FAILED_JOB
Failed Step: $FAILED_STEP

FAILED STEPS SUMMARY:
$STEP_SUMMARY

NOTE: This is a fallback summary. Full logs may be available in the GitHub UI.

For complete logs, view the workflow run:
${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID

TROUBLESHOOTING:
If you need full logs, ensure:
1. The 'actions=read' permission is granted at job level
2. Logs are available (not purged by retention policy)
3. The job has completed execution
FALLBACK_EOF
                else
                  LOG_FETCH_STATUS="logs_unavailable"

                  echo "⚠️  Warning: No step details available in fallback"

                  cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: LOGS UNAVAILABLE ===

Full job logs and step details could not be retrieved.

Job ID: $JOB_ID
Job Name: $FAILED_JOB
Run ID: $RUN_ID

This may occur if:
- The job is still in progress
- Logs have not been uploaded yet
- API permissions are insufficient
- Logs were purged by retention policy

ACTION REQUIRED:
View the workflow run in GitHub UI for detailed logs and step information:
${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID

NEXT STEPS:
1. Review the workflow run in GitHub UI
2. Identify the failed step and error message
3. Debug the issue based on the error output
4. Retry the workflow after fixing the issue
FALLBACK_EOF
                fi
              else
                LOG_FETCH_STATUS="fallback_api_error"

                echo "❌ Fallback failed: Invalid JSON response"

                cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: ALL METHODS EXHAUSTED ===

Error Type: API Errors in Primary and Fallback Methods
Job ID: $JOB_ID
Job Name: $FAILED_JOB

Both the primary log fetch method and fallback step summary extraction failed.
This indicates a more serious issue with API access or workflow configuration.

CRITICAL TROUBLESHOOTING STEPS:
1. Verify 'actions=read' permission is correctly set in workflow YAML
2. Check GitHub Status: https://www.githubstatus.com
3. Review organization security policies for API restrictions
4. Ensure GITHUB_TOKEN has not been revoked or restricted
5. View workflow run in GitHub UI: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID

If the issue persists after checking the above, contact GitHub Support.
FALLBACK_EOF
              fi
            else
              LOG_FETCH_STATUS="fallback_failed"

              echo "❌ Fallback failed: API request error"

              cat > job_logs.txt <<FALLBACK_EOF
=== LOG FETCH FAILED: ALL METHODS EXHAUSTED ===

Error Type: Complete API Failure
Job ID: $JOB_ID
Job Name: $FAILED_JOB

All attempts to fetch job logs and step details have failed:
- Primary logs API: Failed
- Fallback step summary API: Failed

This indicates a critical issue with GitHub Actions API access.

IMMEDIATE ACTION REQUIRED:
1. Check GitHub Status: https://www.githubstatus.com
2. Verify network connectivity
3. Review workflow permissions configuration
4. Check for organization-level API restrictions

View workflow run in GitHub UI:
${{ github.server_url }}/${{ github.repository }}/actions/runs/$RUN_ID

Contact GitHub Support if the issue persists.
FALLBACK_EOF
            fi
            rm -f "$FALLBACK_RESPONSE"
          fi

          # Clean up temp files
          rm -f "$LOGS_RESPONSE"

          # ==========================================
          # STEP 6: Final status summary
          # ==========================================
          echo "=========================================="
          echo "Log Fetch Summary"
          echo "=========================================="
          echo "Job Name: $FAILED_JOB"
          echo "Job ID: $JOB_ID"
          echo "Failed Step: $FAILED_STEP"
          echo "Status: $LOG_FETCH_STATUS"

          if [ -n "$ERROR_DETAILS" ]; then
            echo "Error Details: $ERROR_DETAILS"
          fi

          if [ -f job_logs.txt ]; then
            LOG_FILE_SIZE=$(wc -c < job_logs.txt)
            echo "Log File: job_logs.txt ($LOG_FILE_SIZE bytes)"
          fi

          echo "=========================================="
          echo ""

          # Always exit 0 to continue workflow even if logs couldn't be fetched
          exit 0

      - name: Create markdown file for bug
        run: |
          FEATURE_ID="${{ steps.feature.outputs.feature_id }}"
          FAILED_JOB="${{ env.FAILED_JOB }}"
          FAILED_STEP="${{ steps.fetch-logs.outputs.failed_step }}"
          TITLE="${{ steps.failed-job.outputs.title }}"
          BUG_ID="${{ env.NEXT_BUG_ID }}"
          WORKFLOW_URL="${{ env.WORKFLOW_URL }}"

          # Handle case where failed_step might be empty
          if [ -z "$FAILED_STEP" ]; then
            FAILED_STEP="Unknown"
          fi

          # Create bugs directory if it doesn't exist
          BUGS_DIR="docs/features/${FEATURE_ID}/bugs"
          mkdir -p "$BUGS_DIR"

          # Create markdown file path
          BUG_FILE="${BUGS_DIR}/${BUG_ID}.md"

          # Write the bug report using echo commands
          echo "# Bug Report: ${TITLE}" > "$BUG_FILE"
          echo "" >> "$BUG_FILE"
          echo "## Failed Job" >> "$BUG_FILE"
          echo "${FAILED_JOB}" >> "$BUG_FILE"
          echo "" >> "$BUG_FILE"
          echo "## Failed Step" >> "$BUG_FILE"
          echo "${FAILED_STEP}" >> "$BUG_FILE"
          echo "" >> "$BUG_FILE"
          echo "## Raw Logs" >> "$BUG_FILE"
          echo '```' >> "$BUG_FILE"

          # Append logs if available
          if [ -f job_logs.txt ]; then
            cat job_logs.txt >> "$BUG_FILE"
          else
            echo "No logs available" >> "$BUG_FILE"
          fi

          # Close the code block and add workflow URL
          echo '```' >> "$BUG_FILE"
          echo "" >> "$BUG_FILE"
          echo "## Workflow Run" >> "$BUG_FILE"
          echo "${WORKFLOW_URL}" >> "$BUG_FILE"

          echo "✅ Markdown file created: $BUG_FILE"
          echo ""
          echo "Bug report preview:"
          echo "===================="
          head -n 20 "$BUG_FILE"
          echo "..."

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push bug log
        run: |
          FEATURE_ID="${{ steps.feature.outputs.feature_id }}"
          BUG_ID="${{ env.NEXT_BUG_ID }}"

          # Add both the bug-log.json and the markdown file
          git add docs/features/bug-log.json
          git add "docs/features/${FEATURE_ID}/bugs/${BUG_ID}.md"

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "$(cat <<'EOF'
          Add bug report for ${{ steps.failed-job.outputs.title }}

          Bug ID: ${{ env.NEXT_BUG_ID }}
          Feature: ${{ steps.feature.outputs.branch_name }}
          Failed Job: ${{ steps.failed-job.outputs.failed_job }}
          Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          🤖 Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>
          EOF
          )"

            git push
            echo "✅ Bug log committed and pushed successfully"
          fi