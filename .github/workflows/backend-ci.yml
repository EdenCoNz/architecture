name: Backend CI/CD

# Trigger only on pull requests to main branch
on:
  push:
    branches: [main, 'feature/**']
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci.yml'
  workflow_dispatch:  # Allow manual triggering

# Explicit permissions (least privilege)
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  security-events: write  # For uploading security scan results

# Prevent concurrent runs for same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Job 1: Lint and Format Check
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    # Only run on feature branches for PRs, or always for pushes/manual triggers
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'feature/')

    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/requirements/dev.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/dev.txt

      - name: Run Black formatter check
        run: black --check .

      - name: Run isort import sorter check
        run: isort --check-only .

      - name: Run Flake8 linter
        run: flake8

      - name: Generate lint summary
        if: always()
        run: |
          echo "## Code Quality Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Black formatting: $(black --check . && echo '✅ Passed' || echo '❌ Failed')" >> $GITHUB_STEP_SUMMARY
          echo "- isort imports: $(isort --check-only . && echo '✅ Passed' || echo '❌ Failed')" >> $GITHUB_STEP_SUMMARY
          echo "- Flake8 linting: $(flake8 && echo '✅ Passed' || echo '❌ Failed')" >> $GITHUB_STEP_SUMMARY

  # Job 2: Type Check
  typecheck:
    name: Type Check with mypy
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    # Only run on feature branches for PRs, or always for pushes/manual triggers
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'feature/')

    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/requirements/dev.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/dev.txt

      - name: Run mypy type checker
        run: mypy apps/

  # Job 3: Unit and Integration Tests with Coverage
  test:
    name: Tests with Coverage
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    # Only run on feature branches for PRs, or always for pushes/manual triggers
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'feature/')

    defaults:
      run:
        working-directory: ./backend

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: test_backend_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/requirements/dev.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/dev.txt

      - name: Run tests with coverage
        env:
          DB_NAME: test_backend_db
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_HOST: localhost
          DB_PORT: 5432
          REDIS_URL: redis://localhost:6379/1
          SECRET_KEY: test-secret-key-for-ci-testing-only
          DEBUG: 'False'
        run: |
          pytest --cov=apps \
                 --cov-report=xml \
                 --cov-report=html \
                 --cov-report=term-missing \
                 --junitxml=pytest-report.xml \
                 -n auto

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ github.sha }}
          path: |
            backend/htmlcov/
            backend/coverage.xml
          retention-days: 30
          if-no-files-found: error

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results-${{ github.sha }}
          path: backend/pytest-report.xml
          retention-days: 30

      - name: Generate test summary
        if: always()
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Parse pytest output for test statistics
          if [ -f "pytest-report.xml" ]; then
            echo "### Test Execution" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Use Python to parse JUnit XML
            python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('pytest-report.xml')
          root = tree.getroot()
          tests = root.get('tests', '0')
          failures = root.get('failures', '0')
          errors = root.get('errors', '0')
          skipped = root.get('skipped', '0')
          time = root.get('time', '0')

          passed = int(tests) - int(failures) - int(errors) - int(skipped)

          print(f'- Total Tests: {tests}')
          print(f'- Passed: {passed} ✅')
          print(f'- Failed: {failures} ❌')
          print(f'- Errors: {errors} ⚠️')
          print(f'- Skipped: {skipped} ⏭️')
          print(f'- Duration: {float(time):.2f}s')
          " >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Coverage summary
          if [ -f "coverage.xml" ]; then
            echo "### Coverage Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()

          line_rate = float(root.get('line-rate', 0)) * 100
          branch_rate = float(root.get('branch-rate', 0)) * 100

          print(f'- Line Coverage: {line_rate:.1f}%')
          print(f'- Branch Coverage: {branch_rate:.1f}%')
          " >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "Full coverage reports are available as workflow artifacts." >> $GITHUB_STEP_SUMMARY

  # Job 4: Security Audit
  security:
    name: Security Audit
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    # Only run on feature branches for PRs, or always for pushes/manual triggers
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'feature/')

    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/requirements/dev.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/dev.txt

      - name: Run pip safety check
        run: |
          pip install safety
          safety check --json --output safety-report.json || true
        continue-on-error: true

      - name: Run Bandit security linter
        run: |
          pip install bandit[toml]
          bandit -r apps/ -f json -o bandit-report.json || true
        continue-on-error: true

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ github.sha }}
          path: |
            backend/safety-report.json
            backend/bandit-report.json
          retention-days: 30
          if-no-files-found: warn

      - name: Security audit summary
        if: always()
        run: |
          echo "## Security Audit Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "safety-report.json" ]; then
            echo "### Dependency Vulnerabilities (Safety)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            python -c "
          import json
          try:
              with open('safety-report.json', 'r') as f:
                  data = json.load(f)

              if isinstance(data, list) and len(data) > 0:
                  print(f'⚠️ Found {len(data)} vulnerabilities')
                  for vuln in data[:5]:  # Show first 5
                      pkg = vuln.get('package', 'Unknown')
                      version = vuln.get('installed_version', 'Unknown')
                      vuln_id = vuln.get('vulnerability_id', 'Unknown')
                      print(f'- {pkg} {version}: {vuln_id}')
              else:
                  print('✅ No known vulnerabilities detected')
          except Exception as e:
              print(f'Unable to parse safety report: {e}')
          " >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f "bandit-report.json" ]; then
            echo "### Code Security Issues (Bandit)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            python -c "
          import json
          try:
              with open('bandit-report.json', 'r') as f:
                  data = json.load(f)

              results = data.get('results', [])
              metrics = data.get('metrics', {})

              if results:
                  high = sum(1 for r in results if r.get('issue_severity') == 'HIGH')
                  medium = sum(1 for r in results if r.get('issue_severity') == 'MEDIUM')
                  low = sum(1 for r in results if r.get('issue_severity') == 'LOW')

                  print(f'- HIGH severity: {high}')
                  print(f'- MEDIUM severity: {medium}')
                  print(f'- LOW severity: {low}')
              else:
                  print('✅ No security issues detected')
          except Exception as e:
              print(f'Unable to parse bandit report: {e}')
          " >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  # Job 5: Build Verification
  build:
    name: Build Verification
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: [lint, typecheck, test, security]  # Only build if all checks pass
    # Only run on feature branches for PRs, or always for pushes/manual triggers
    if: github.event_name != 'pull_request' || startsWith(github.head_ref, 'feature/')

    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/requirements/prod.txt

      - name: Install production dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/prod.txt

      - name: Collect static files
        env:
          SECRET_KEY: build-verification-secret-key
          DB_NAME: sqlite
          DEBUG: 'False'
        run: |
          python manage.py collectstatic --noinput --verbosity 2

      - name: Check Django configuration
        env:
          SECRET_KEY: build-verification-secret-key
          DB_NAME: sqlite
          DEBUG: 'False'
        run: |
          python manage.py check --deploy

      - name: Verify migrations
        env:
          SECRET_KEY: build-verification-secret-key
          DB_NAME: sqlite
          DEBUG: 'False'
        run: |
          python manage.py makemigrations --check --dry-run

      - name: Build summary
        run: |
          echo "## Build Verification Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Production dependencies installed" >> $GITHUB_STEP_SUMMARY
          echo "✅ Static files collected successfully" >> $GITHUB_STEP_SUMMARY
          echo "✅ Django deployment checks passed" >> $GITHUB_STEP_SUMMARY
          echo "✅ Migration state verified" >> $GITHUB_STEP_SUMMARY

  # Job 6: Auto-Close Issue from Commit Message
  auto-close-issue-from-commit:
    name: Auto-Close Issue from Commit Message
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    # Always run this job, regardless of whether previous jobs succeeded or failed
    if: always()
    permissions:
      issues: write
      contents: read

    steps:
      - name: Get commit message
        id: get-message
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PR events, fetch the latest commit message
            SHA="${{ github.event.pull_request.head.sha }}"
            MESSAGE=$(gh api repos/${{ github.repository }}/commits/${SHA} --jq '.commit.message')
            echo "sha=${SHA}" >> $GITHUB_OUTPUT
            echo "message<<EOF" >> $GITHUB_OUTPUT
            echo "${MESSAGE}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            # For workflow_dispatch events, use the current commit
            SHA="${{ github.sha }}"
            MESSAGE=$(gh api repos/${{ github.repository }}/commits/${SHA} --jq '.commit.message')
            echo "sha=${SHA}" >> $GITHUB_OUTPUT
            echo "message<<EOF" >> $GITHUB_OUTPUT
            echo "${MESSAGE}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

          echo "## Commit Message Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Extract issue numbers from commit message
        id: extract-issues
        run: |
          COMMIT_MESSAGE='${{ steps.get-message.outputs.message }}'

          echo "**Commit Message**:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$COMMIT_MESSAGE" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Extract issue numbers using pattern: "fix issue #123" or "Fix issue #123" (case insensitive)
          # This regex matches variations like:
          # - "fix issue #123"
          # - "Fix issue #456"
          # - "fixes issue #789"
          # - "fixed issue #999"
          ISSUE_NUMBERS=$(echo "$COMMIT_MESSAGE" | grep -iEo 'fix(es|ed)? issue #[0-9]+' | grep -oE '[0-9]+' | sort -u)

          if [ -z "$ISSUE_NUMBERS" ]; then
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "ℹ️ No issue references found in commit message" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Pattern**: Looking for 'fix issue #<number>' (case insensitive)" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Convert to comma-separated list for output
          ISSUE_LIST=$(echo "$ISSUE_NUMBERS" | tr '\n' ',' | sed 's/,$//')

          echo "has_issues=true" >> $GITHUB_OUTPUT
          echo "issue_list=$ISSUE_LIST" >> $GITHUB_OUTPUT
          echo "issue_count=$(echo "$ISSUE_NUMBERS" | wc -l)" >> $GITHUB_OUTPUT

          echo "✅ Found issue reference(s) in commit message:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          for issue in $ISSUE_NUMBERS; do
            echo "- Issue #$issue" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Close referenced issues
        if: steps.extract-issues.outputs.has_issues == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE_LIST="${{ steps.extract-issues.outputs.issue_list }}"
          COMMIT_SHA="${{ steps.get-message.outputs.sha }}"
          WORKFLOW_STATUS="${{ job.status }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "## Closing Issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**CI Status**: $WORKFLOW_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY
          echo "**Run URL**: $RUN_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          CLOSED_COUNT=0
          FAILED_COUNT=0

          # Split comma-separated list and process each issue
          IFS=',' read -ra ISSUES <<< "$ISSUE_LIST"
          for ISSUE_NUMBER in "${ISSUES[@]}"; do
            echo "Processing issue #$ISSUE_NUMBER..." >> $GITHUB_STEP_SUMMARY

            # Check if issue exists and is open
            ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "${{ github.repository }}" --json state --jq '.state' 2>/dev/null || echo "NOT_FOUND")

            if [ "$ISSUE_STATE" = "NOT_FOUND" ]; then
              echo "  ⚠️ Issue #$ISSUE_NUMBER does not exist" >> $GITHUB_STEP_SUMMARY
              FAILED_COUNT=$((FAILED_COUNT + 1))
              continue
            fi

            if [ "$ISSUE_STATE" = "CLOSED" ]; then
              echo "  ℹ️ Issue #$ISSUE_NUMBER is already closed" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            # Create close comment based on CI status
            if [ "$WORKFLOW_STATUS" = "success" ]; then
              CLOSE_COMMENT="Automatically closed by commit $COMMIT_SHA - Backend CI/CD workflow completed successfully.

          **Run URL**: $RUN_URL
          **Workflow**: Backend CI/CD
          **Status**: ✅ All checks passed"
            else
              CLOSE_COMMENT="Automatically closed by commit $COMMIT_SHA - Backend CI/CD workflow completed (some checks may have failed).

          **Run URL**: $RUN_URL
          **Workflow**: Backend CI/CD
          **Status**: ⚠️ Some checks failed (see run for details)"
            fi

            # Close the issue
            if gh issue close "$ISSUE_NUMBER" \
              --repo "${{ github.repository }}" \
              --comment "$CLOSE_COMMENT" 2>&1; then
              echo "  ✅ Successfully closed issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
              CLOSED_COUNT=$((CLOSED_COUNT + 1))
            else
              echo "  ❌ Failed to close issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Issues processed: ${#ISSUES[@]}" >> $GITHUB_STEP_SUMMARY
          echo "- Successfully closed: $CLOSED_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- Failed/Skipped: $FAILED_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $CLOSED_COUNT -gt 0 ]; then
            echo "✅ Auto-close from commit message completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ No issues were closed" >> $GITHUB_STEP_SUMMARY
          fi

  # Job 8: Detect Workflow Failures
  detect-workflow-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure() || cancelled()
    permissions:
      issues: write
      contents: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Report workflow failure
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "## Workflow Issue Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "⚠️ Workflow was manually triggered and had failures." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ job.status }}" == "cancelled" ]; then
            echo "⚠️ Workflow was cancelled." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ One or more jobs in this workflow have failed." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Creating GitHub issue for workflow failure..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Analyze workflow failures
        id: analyze-failures
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch workflow run details
          RUN_ID="${{ github.run_id }}"

          echo "## Analyzing Workflow Failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID**: $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Fetch all jobs for this workflow run
          JOBS_JSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/$RUN_ID/jobs")

          # Count failed and cancelled jobs
          FAILED_JOBS=$(echo "$JOBS_JSON" | jq '[.jobs[] | select(.conclusion == "failure")] | length')
          CANCELLED_JOBS=$(echo "$JOBS_JSON" | jq '[.jobs[] | select(.conclusion == "cancelled")] | length')
          TOTAL_JOBS=$(echo "$JOBS_JSON" | jq '.total_count')

          echo "failed_jobs=$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "cancelled_jobs=$CANCELLED_JOBS" >> $GITHUB_OUTPUT
          echo "total_jobs=$TOTAL_JOBS" >> $GITHUB_OUTPUT

          # Extract first failed job details for issue creation
          FIRST_FAILED_JOB=$(echo "$JOBS_JSON" | jq -r '[.jobs[] | select(.conclusion == "failure")][0]')

          if [ "$FIRST_FAILED_JOB" != "null" ] && [ -n "$FIRST_FAILED_JOB" ]; then
            JOB_NAME=$(echo "$FIRST_FAILED_JOB" | jq -r '.name')
            JOB_ID=$(echo "$FIRST_FAILED_JOB" | jq -r '.id')
            JOB_URL=$(echo "$FIRST_FAILED_JOB" | jq -r '.html_url')
            FAILED_STEP=$(echo "$FIRST_FAILED_JOB" | jq -r '.steps[] | select(.conclusion == "failure") | .name' | head -n 1)

            if [ -z "$FAILED_STEP" ]; then
              FAILED_STEP="Job-level failure"
            fi

            echo "job_name=$JOB_NAME" >> $GITHUB_OUTPUT
            echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
            echo "job_url=$JOB_URL" >> $GITHUB_OUTPUT
            echo "failed_step=$FAILED_STEP" >> $GITHUB_OUTPUT
            echo "has_failures=true" >> $GITHUB_OUTPUT

            echo "**First Failed Job**: $JOB_NAME" >> $GITHUB_STEP_SUMMARY
            echo "**Failed Step**: $FAILED_STEP" >> $GITHUB_STEP_SUMMARY
          else
            echo "has_failures=false" >> $GITHUB_OUTPUT
            echo "**Note**: No failed jobs found, workflow may have been cancelled" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Summary**:" >> $GITHUB_STEP_SUMMARY
          echo "- Total Jobs: $TOTAL_JOBS" >> $GITHUB_STEP_SUMMARY
          echo "- Failed Jobs: $FAILED_JOBS" >> $GITHUB_STEP_SUMMARY
          echo "- Cancelled Jobs: $CANCELLED_JOBS" >> $GITHUB_STEP_SUMMARY

      - name: Create failure tracking issue
        if: steps.analyze-failures.outputs.has_failures == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Extract metadata
          WORKFLOW_NAME="Backend CI/CD"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          JOB_NAME="${{ steps.analyze-failures.outputs.job_name }}"
          FAILED_STEP="${{ steps.analyze-failures.outputs.failed_step }}"
          BRANCH="${{ github.ref_name }}"

          # Extract feature ID if this is a feature branch
          if [[ "$BRANCH" =~ ^feature/([0-9]+) ]]; then
            FEATURE_ID="${BASH_REMATCH[1]}"
            FEATURE_NAME="$BRANCH"
          else
            FEATURE_ID="N/A"
            FEATURE_NAME="N/A"
          fi

          # Determine PR URL
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            PR_URL="${{ github.event.pull_request.html_url }}"
          else
            PR_URL="N/A"
          fi

          # Create issue title
          ISSUE_TITLE="Workflow Failure: $WORKFLOW_NAME - $JOB_NAME - $FAILED_STEP"

          # Write issue body to temp file using echo
          {
            echo "Workflow: $WORKFLOW_NAME - Job: $JOB_NAME - Step: $FAILED_STEP"
            echo ""
            echo "Branch: $BRANCH"
            echo ""
            echo "Metadata Table:"
            echo "- title: $ISSUE_TITLE"
            echo "- featureID: $FEATURE_ID"
            echo "- featureName: $FEATURE_NAME"
            echo "- jobName: $JOB_NAME"
            echo "- stepName: $FAILED_STEP"
            echo "- PRURL: $PR_URL"
            echo "- commitURL: $COMMIT_URL"
            echo "- runURL: $RUN_URL"
            echo ""
            echo "Review logs at runURL above, fix the issue, and commit with 'Fix issue #N' to auto-close."
          } > /tmp/issue_body.md

          # Check for duplicate by searching existing issues with same title
          echo "Checking for duplicate issues..." >> $GITHUB_STEP_SUMMARY

          DUPLICATE_NUMBER=$(gh issue list --state open --limit 100 --search "in:title $ISSUE_TITLE" --json number --jq '.[0].number // empty')

          if [ -n "$DUPLICATE_NUMBER" ]; then
            echo "⚠️ Duplicate issue found: #$DUPLICATE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "Adding 'attempted' label to existing issue..." >> $GITHUB_STEP_SUMMARY

            gh issue edit "$DUPLICATE_NUMBER" --add-label "attempted" || true

            echo "✓ Updated existing issue #$DUPLICATE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Issue URL**: https://github.com/${{ github.repository }}/issues/$DUPLICATE_NUMBER" >> $GITHUB_STEP_SUMMARY
          else
            echo "No duplicate found, creating new issue..." >> $GITHUB_STEP_SUMMARY

            # Create the issue from file
            ISSUE_URL=$(gh issue create \
              --title "$ISSUE_TITLE" \
              --body-file /tmp/issue_body.md)

            ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')

            echo "✓ Created issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Issue URL**: $ISSUE_URL" >> $GITHUB_STEP_SUMMARY
          fi
