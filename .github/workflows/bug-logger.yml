name: Bug Logger - Create GitHub Issues for CI/CD Failures

# This is a reusable workflow that creates GitHub issues when CI/CD jobs fail
# It can be called from any workflow in this repository
# See: https://docs.github.com/en/actions/using-workflows/reusing-workflows

on:
  workflow_call:
    inputs:
      job_results:
        description: 'JSON string containing the results of all jobs from the calling workflow'
        required: true
        type: string
      branch_name:
        description: 'Name of the branch where the failure occurred'
        required: true
        type: string
      pr_number:
        description: 'Pull request number (if applicable)'
        required: false
        type: string
      pr_url:
        description: 'Pull request URL (if applicable)'
        required: false
        type: string
      pr_author:
        description: 'Pull request author username'
        required: false
        type: string
      run_id:
        description: 'GitHub Actions run ID'
        required: true
        type: string

# Minimal permissions for bug logging (principle of least privilege)
permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

jobs:
  create-bug-issue:
    name: Create Bug Issue
    runs-on: ubuntu-22.04
    timeout-minutes: 5

    # Expose outputs for the bug resolver job
    outputs:
      is_retry: ${{ steps.check-duplicate.outputs.is_retry }}
      retry_of_issue: ${{ steps.check-duplicate.outputs.retry_of_issue }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract feature/bug information
        id: extract-info
        run: |
          BRANCH_NAME="${{ inputs.branch_name }}"
          echo "Branch name: $BRANCH_NAME"

          # Extract feature ID from branch name (e.g., feature/123-description -> 123)
          if [[ "$BRANCH_NAME" =~ ^feature/([0-9]+) ]]; then
            FEATURE_ID="${BASH_REMATCH[1]}"
            echo "feature_id=$FEATURE_ID" >> $GITHUB_OUTPUT
            echo "Extracted feature ID: $FEATURE_ID"
          elif [[ "$BRANCH_NAME" =~ ^bug/([0-9]+) ]]; then
            BUG_ID="${BASH_REMATCH[1]}"
            echo "feature_id=$BUG_ID" >> $GITHUB_OUTPUT
            echo "Extracted bug ID: $BUG_ID"
          else
            echo "feature_id=" >> $GITHUB_OUTPUT
            echo "No feature/bug ID found in branch name"
          fi

          # Extract feature name from branch name (e.g., feature/123-my-feature -> my-feature)
          if [[ "$BRANCH_NAME" =~ ^(feature|bug)/[0-9]+-(.+)$ ]]; then
            FEATURE_NAME="${BASH_REMATCH[2]}"
            echo "feature_name=$FEATURE_NAME" >> $GITHUB_OUTPUT
            echo "Extracted feature name: $FEATURE_NAME"
          else
            echo "feature_name=" >> $GITHUB_OUTPUT
          fi

      - name: Parse job results and identify failures
        id: parse-failures
        run: |
          # Parse the job_results JSON to find failed jobs
          JOB_RESULTS='${{ inputs.job_results }}'
          echo "Job results: $JOB_RESULTS"

          # Extract failed job names
          FAILED_JOBS=$(echo "$JOB_RESULTS" | jq -r 'to_entries | map(select(.value.result == "failure")) | .[].key' | tr '\n' ',' | sed 's/,$//')
          echo "failed_jobs=$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "Failed jobs: $FAILED_JOBS"

          # Count failed jobs
          FAILURE_COUNT=$(echo "$FAILED_JOBS" | grep -o ',' | wc -l)
          FAILURE_COUNT=$((FAILURE_COUNT + 1))
          echo "failure_count=$FAILURE_COUNT" >> $GITHUB_OUTPUT
          echo "Number of failures: $FAILURE_COUNT"

          # Get first failed job for the title
          FIRST_FAILED_JOB=$(echo "$FAILED_JOBS" | cut -d',' -f1)
          echo "first_failed_job=$FIRST_FAILED_JOB" >> $GITHUB_OUTPUT
          echo "First failed job: $FIRST_FAILED_JOB"

      - name: Fetch workflow logs
        id: fetch-logs
        run: |
          # Fetch workflow run details using GitHub CLI
          echo "Fetching workflow run logs for run ID: ${{ inputs.run_id }}"

          # Get workflow run details
          gh run view ${{ inputs.run_id }} --json jobs > workflow_jobs.json

          # Get the failed job details
          FAILED_JOB_NAME="${{ steps.parse-failures.outputs.first_failed_job }}"
          echo "Looking for job: $FAILED_JOB_NAME"

          # Debug: Show available jobs
          echo "Available jobs in workflow:"
          cat workflow_jobs.json | jq -r '.jobs[].name'

          # Extract the job ID for the failed job
          JOB_ID=$(cat workflow_jobs.json | jq -r ".jobs[] | select(.name | contains(\"$FAILED_JOB_NAME\")) | .databaseId" | head -1)
          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
          echo "Failed job ID: $JOB_ID"

          # Debug: Show job steps if job ID was found
          if [ -n "$JOB_ID" ]; then
            echo "Steps for job $JOB_ID:"
            cat workflow_jobs.json | jq -r ".jobs[] | select(.databaseId == $JOB_ID) | .steps[] | \"\(.number): \(.name) (conclusion: \(.conclusion // \"none\"))\""
          fi

          # Get the full logs for the failed job
          if [ -n "$JOB_ID" ]; then
            echo "Fetching logs for job ID: $JOB_ID"
            gh run view --job=$JOB_ID --log > job_logs_full.txt || echo "Could not fetch logs"

            # Extract the failed step name from the job
            # GitHub Actions API returns step names in the .name field
            # If a step doesn't have an explicit 'name:' field in the workflow YAML,
            # GitHub will auto-generate one based on the action or command
            FAILED_STEP=$(cat workflow_jobs.json | jq -r ".jobs[] | select(.databaseId == $JOB_ID) | .steps[] | select(.conclusion == \"failure\") | .name" | head -1)

            # If no step name found, try to get the first failed step's number
            if [ -z "$FAILED_STEP" ] || [ "$FAILED_STEP" = "null" ]; then
              echo "Warning: No step name found in API response, attempting to extract step number"
              FAILED_STEP_NUMBER=$(cat workflow_jobs.json | jq -r ".jobs[] | select(.databaseId == $JOB_ID) | .steps[] | select(.conclusion == \"failure\") | .number" | head -1)
              if [ -n "$FAILED_STEP_NUMBER" ] && [ "$FAILED_STEP_NUMBER" != "null" ]; then
                FAILED_STEP="Step $FAILED_STEP_NUMBER"
                echo "Using step number: $FAILED_STEP"
              else
                FAILED_STEP="Unknown"
                echo "Warning: Could not determine failed step name or number"
              fi
            fi

            echo "failed_step=$FAILED_STEP" >> $GITHUB_OUTPUT
            echo "Failed step: $FAILED_STEP"

            # Extract failure context (last 50 lines which usually contain the error)
            tail -50 job_logs_full.txt > log_excerpt.txt || echo "No logs available"

            # Extract line numbers from the log excerpt (first and last line numbers)
            # Line numbers are typically formatted as "2023-10-20T12:34:56.789Z ##[group]Run npm ci"
            # Or as numbered lines in the GitHub Actions UI
            FIRST_LINE=$(head -1 log_excerpt.txt | grep -oP '^\d+' || echo "1")
            LAST_LINE=$(tail -1 log_excerpt.txt | grep -oP '^\d+' || echo "50")

            # If we can't extract actual line numbers, calculate based on total lines
            TOTAL_LINES=$(wc -l < job_logs_full.txt)
            if [ "$FIRST_LINE" = "1" ] && [ "$LAST_LINE" = "50" ]; then
              FIRST_LINE=$((TOTAL_LINES - 50 > 0 ? TOTAL_LINES - 50 : 1))
              LAST_LINE=$TOTAL_LINES
            fi

            LOG_LINE_RANGE="L${FIRST_LINE}-L${LAST_LINE}"
            echo "log_line_numbers=$LOG_LINE_RANGE" >> $GITHUB_OUTPUT
            echo "Log line numbers: $LOG_LINE_RANGE"

            # Save log excerpt for later use
            echo "Log excerpt saved"
          else
            echo "Could not find job ID for failed job"
            echo "No logs available" > log_excerpt.txt
            echo "failed_step=Unknown" >> $GITHUB_OUTPUT
            echo "log_line_numbers=L0-L0" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create bug log content
        id: create-bug-log
        run: |
          # Create bug log based on template
          BRANCH_NAME="${{ inputs.branch_name }}"
          FEATURE_ID="${{ steps.extract-info.outputs.feature_id }}"
          FEATURE_NAME="${{ steps.extract-info.outputs.feature_name }}"
          FAILED_JOB="${{ steps.parse-failures.outputs.first_failed_job }}"
          FAILED_STEP="${{ steps.fetch-logs.outputs.failed_step }}"
          LOG_LINE_NUMBERS="${{ steps.fetch-logs.outputs.log_line_numbers }}"
          PR_URL="${{ inputs.pr_url }}"
          COMMIT_SHA="${{ github.sha }}"
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ inputs.run_id }}"

          # Generate bug log content
          cat > bug_log.md <<EOF
          # Bug Log - CI/CD Failure

          | Field | Value |
          |-------|-------|
          | title | [$BRANCH_NAME] $FAILED_JOB job failed |
          | featureID | $FEATURE_ID |
          | featureName | $FEATURE_NAME |
          | jobName | $FAILED_JOB |
          | stepName | $FAILED_STEP |
          | logLineNumbers | $LOG_LINE_NUMBERS |
          | PRURL | $PR_URL |
          | commitURL | https://github.com/${{ github.repository }}/commit/$COMMIT_SHA |
          | runURL | $RUN_URL |

          ## Failed Step Log Excerpt

          The following shows the failed step's output (lines $LOG_LINE_NUMBERS). For the complete workflow logs, see the [workflow run]($RUN_URL).

          \`\`\`
          $(cat log_excerpt.txt)
          \`\`\`

          ## How to Fix

          1. Review the failure logs above
          2. Check the [complete workflow run]($RUN_URL) for full context
          3. Fix the issue in your branch
          4. Push changes to trigger a new CI/CD run

          ## Related Links

          - Pull Request: $PR_URL
          - Commit: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA
          - Workflow Run: $RUN_URL
          EOF

          echo "Bug log content created"
          cat bug_log.md

      - name: Check for duplicate issues and retry detection
        id: check-duplicate
        run: |
          echo "=========================================="
          echo "Starting Duplicate and Retry Detection"
          echo "=========================================="

          # Current failure context
          CURRENT_TITLE="[${{ inputs.branch_name }}] ${{ steps.parse-failures.outputs.first_failed_job }} job failed"
          CURRENT_FEATURE_ID="${{ steps.extract-info.outputs.feature_id }}"
          CURRENT_JOB_NAME="${{ steps.parse-failures.outputs.first_failed_job }}"
          CURRENT_STEP_NAME="${{ steps.fetch-logs.outputs.failed_step }}"
          CURRENT_LOG_LINES="${{ steps.fetch-logs.outputs.log_line_numbers }}"

          echo "Current failure context:"
          echo "  Title: $CURRENT_TITLE"
          echo "  Feature ID: $CURRENT_FEATURE_ID"
          echo "  Job Name: $CURRENT_JOB_NAME"
          echo "  Step Name: $CURRENT_STEP_NAME"
          echo "  Log Lines: $CURRENT_LOG_LINES"
          echo ""

          # Initialize flags
          IS_DUPLICATE=false
          DUPLICATE_ISSUE_NUMBER=""
          OLD_ISSUE_NUMBER=""
          OLD_ISSUE_NEEDS_FIX_PENDING=false
          IS_RETRY=false
          RETRY_OF_ISSUE=""
          ATTEMPT_COUNT=1

          # STEP 1: Search for open issues with matching title pattern
          echo "=========================================="
          echo "STEP 1: Checking for Open Issues (Duplicates)"
          echo "=========================================="
          EXISTING_ISSUES=$(gh issue list \
            --repo ${{ github.repository }} \
            --state open \
            --search "\"$CURRENT_TITLE\" in:title" \
            --json number,title,body \
            --limit 10)

          echo "Found $(echo "$EXISTING_ISSUES" | jq '. | length') open issues with similar titles"

          # Check each existing open issue
          if [ "$(echo "$EXISTING_ISSUES" | jq '. | length')" -gt 0 ]; then
            echo ""
            echo "Analyzing open issues for duplicates..."

            echo "$EXISTING_ISSUES" | jq -c '.[]' | while read -r issue; do
              ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
              ISSUE_BODY=$(echo "$issue" | jq -r '.body')

              echo ""
              echo "Checking issue #$ISSUE_NUMBER..."

              # Extract fields from issue body
              PREV_FEATURE_ID=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*featureID\s*\|\s*\K[^\|]+' | tr -d ' ')
              PREV_JOB_NAME=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*jobName\s*\|\s*\K[^\|]+' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              PREV_STEP_NAME=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*stepName\s*\|\s*\K[^\|]+' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              PREV_LOG_LINES=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*logLineNumbers\s*\|\s*\K[^\|]+' | tr -d ' ')

              echo "  Previous issue context:"
              echo "    Feature ID: $PREV_FEATURE_ID"
              echo "    Job Name: $PREV_JOB_NAME"
              echo "    Step Name: $PREV_STEP_NAME"
              echo "    Log Lines: $PREV_LOG_LINES"

              # Compare all fields
              if [ "$CURRENT_FEATURE_ID" = "$PREV_FEATURE_ID" ] && \
                 [ "$CURRENT_JOB_NAME" = "$PREV_JOB_NAME" ] && \
                 [ "$CURRENT_STEP_NAME" = "$PREV_STEP_NAME" ] && \
                 [ "$CURRENT_LOG_LINES" = "$PREV_LOG_LINES" ]; then
                echo "  Result: DUPLICATE DETECTED (all fields match)"
                echo "is_duplicate=true" >> $GITHUB_OUTPUT
                echo "duplicate_issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
                IS_DUPLICATE=true
                DUPLICATE_ISSUE_NUMBER=$ISSUE_NUMBER
                break
              else
                echo "  Result: NOT a duplicate (fields differ)"
                # This is a different failure - mark this old issue for fix-pending
                if [ -z "$OLD_ISSUE_NUMBER" ]; then
                  OLD_ISSUE_NUMBER=$ISSUE_NUMBER
                  echo "old_issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
                  echo "old_issue_needs_fix_pending=true" >> $GITHUB_OUTPUT
                  echo "  Action: Will mark issue #$ISSUE_NUMBER as fix-pending (different failure detected)"
                fi
              fi
            done
          else
            echo "No existing open issues found with similar titles"
          fi

          # STEP 2: Search for closed issues to detect retries
          # A retry is when a fix was attempted (issue was closed) but CI is still failing
          echo ""
          echo "=========================================="
          echo "STEP 2: Checking for Closed Issues (Retry Detection)"
          echo "=========================================="

          # Only check for retries if this is not a duplicate
          if [ "$IS_DUPLICATE" = false ]; then
            echo "Searching for closed issues with matching feature/job/step..."

            # Search for closed issues with matching title
            CLOSED_ISSUES=$(gh issue list \
              --repo ${{ github.repository }} \
              --state closed \
              --search "\"$CURRENT_TITLE\" in:title" \
              --json number,title,body,labels,closedAt \
              --limit 20)

            echo "Found $(echo "$CLOSED_ISSUES" | jq '. | length') closed issues with similar titles"

            # Track all matching closed issues to count attempts
            MATCHING_CLOSED_ISSUES=""

            if [ "$(echo "$CLOSED_ISSUES" | jq '. | length')" -gt 0 ]; then
              echo ""
              echo "Analyzing closed issues for retry detection..."

              # Iterate through closed issues
              while IFS= read -r issue; do
                ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
                ISSUE_BODY=$(echo "$issue" | jq -r '.body')
                ISSUE_LABELS=$(echo "$issue" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
                CLOSED_AT=$(echo "$issue" | jq -r '.closedAt')

                echo ""
                echo "Checking closed issue #$ISSUE_NUMBER (closed at: $CLOSED_AT)..."
                echo "  Labels: $ISSUE_LABELS"

                # Extract fields from issue body
                PREV_FEATURE_ID=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*featureID\s*\|\s*\K[^\|]+' | tr -d ' ')
                PREV_JOB_NAME=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*jobName\s*\|\s*\K[^\|]+' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                PREV_STEP_NAME=$(echo "$ISSUE_BODY" | grep -oP '^\|\s*stepName\s*\|\s*\K[^\|]+' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

                echo "  Feature ID: $PREV_FEATURE_ID"
                echo "  Job Name: $PREV_JOB_NAME"
                echo "  Step Name: $PREV_STEP_NAME"

                # Compare feature, job, and step (not log lines - those can differ in retries)
                if [ "$CURRENT_FEATURE_ID" = "$PREV_FEATURE_ID" ] && \
                   [ "$CURRENT_JOB_NAME" = "$PREV_JOB_NAME" ] && \
                   [ "$CURRENT_STEP_NAME" = "$PREV_STEP_NAME" ]; then
                  echo "  Result: MATCH - Same feature/job/step as current failure"

                  # Add to matching closed issues list
                  if [ -z "$MATCHING_CLOSED_ISSUES" ]; then
                    MATCHING_CLOSED_ISSUES="$ISSUE_NUMBER"
                  else
                    MATCHING_CLOSED_ISSUES="$MATCHING_CLOSED_ISSUES,$ISSUE_NUMBER"
                  fi

                  # Check if this was a resolved issue (had pending-merge or fix-pending label)
                  if echo "$ISSUE_LABELS" | grep -q "pending-merge\|fix-pending"; then
                    echo "  Status: This issue was marked as resolved/pending"

                    # This is the most recent closed issue that was marked as resolved
                    # Use it as the retry reference
                    if [ "$IS_RETRY" = false ]; then
                      IS_RETRY=true
                      RETRY_OF_ISSUE=$ISSUE_NUMBER
                      echo "  Action: RETRY DETECTED - This failure is a retry of issue #$ISSUE_NUMBER"
                    fi
                  else
                    echo "  Status: This issue was closed without resolution labels"
                  fi
                else
                  echo "  Result: No match (different feature/job/step)"
                fi
              done < <(echo "$CLOSED_ISSUES" | jq -c '.[]')

              # Calculate attempt count: 1 (current) + number of matching closed issues
              if [ -n "$MATCHING_CLOSED_ISSUES" ]; then
                CLOSED_COUNT=$(echo "$MATCHING_CLOSED_ISSUES" | tr ',' '\n' | wc -l)
                ATTEMPT_COUNT=$((CLOSED_COUNT + 1))
                echo ""
                echo "Matching closed issues: $MATCHING_CLOSED_ISSUES"
                echo "Total attempts for this failure: $ATTEMPT_COUNT (including current attempt)"
              fi
            else
              echo "No closed issues found with similar titles"
            fi
          else
            echo "Skipping retry detection (duplicate issue detected)"
          fi

          # Set default outputs if not set
          if [ "$IS_DUPLICATE" = false ]; then
            echo "is_duplicate=false" >> $GITHUB_OUTPUT
            echo "duplicate_issue_number=" >> $GITHUB_OUTPUT
          fi

          if [ -z "$OLD_ISSUE_NUMBER" ]; then
            echo "old_issue_number=" >> $GITHUB_OUTPUT
            echo "old_issue_needs_fix_pending=false" >> $GITHUB_OUTPUT
          fi

          # Set retry detection outputs
          echo "is_retry=$IS_RETRY" >> $GITHUB_OUTPUT
          echo "retry_of_issue=$RETRY_OF_ISSUE" >> $GITHUB_OUTPUT
          echo "attempt_count=$ATTEMPT_COUNT" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Detection Complete"
          echo "=========================================="
          echo "Duplicate Detection:"
          echo "  Is Duplicate: $IS_DUPLICATE"
          if [ "$IS_DUPLICATE" = true ]; then
            echo "  Duplicate Issue: #$DUPLICATE_ISSUE_NUMBER"
          fi
          if [ -n "$OLD_ISSUE_NUMBER" ]; then
            echo "  Old Issue to Mark: #$OLD_ISSUE_NUMBER"
          fi
          echo ""
          echo "Retry Detection:"
          echo "  Is Retry: $IS_RETRY"
          if [ "$IS_RETRY" = true ]; then
            echo "  Retry of Issue: #$RETRY_OF_ISSUE"
          fi
          echo "  Attempt Count: $ATTEMPT_COUNT"
          echo "=========================================="
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Mark old issue as fix-pending
        if: steps.check-duplicate.outputs.old_issue_needs_fix_pending == 'true'
        run: |
          OLD_ISSUE="${{ steps.check-duplicate.outputs.old_issue_number }}"
          echo "Marking issue #$OLD_ISSUE with 'fix-pending' label..."

          # Add fix-pending label to the old issue
          gh issue edit $OLD_ISSUE \
            --add-label "fix-pending" \
            --repo ${{ github.repository }}

          # Add a comment explaining the label
          gh issue comment $OLD_ISSUE \
            --body "A new, different failure has been detected for the same feature/job/step combination. This suggests the original issue may have been resolved. This issue has been marked as \`fix-pending\` for verification." \
            --repo ${{ github.repository }}

          echo "Successfully marked issue #$OLD_ISSUE as fix-pending"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create GitHub issue
        id: create-issue
        if: steps.check-duplicate.outputs.is_duplicate != 'true'
        run: |
          # Create issue title
          BRANCH_NAME="${{ inputs.branch_name }}"
          FAILED_JOB="${{ steps.parse-failures.outputs.first_failed_job }}"
          ISSUE_TITLE="[$BRANCH_NAME] $FAILED_JOB job failed"

          # Create issue body from bug log
          ISSUE_BODY=$(cat bug_log.md)

          # Assign issue to PR author if available
          ASSIGNEE=""
          if [ -n "${{ inputs.pr_author }}" ]; then
            ASSIGNEE="--assignee ${{ inputs.pr_author }}"
          fi

          # Create the issue using GitHub CLI
          echo "Creating GitHub issue..."
          ISSUE_URL=$(gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            $ASSIGNEE \
            --repo ${{ github.repository }})

          echo "issue_url=$ISSUE_URL" >> $GITHUB_OUTPUT
          echo "Issue created: $ISSUE_URL"

          # Extract issue number from URL
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oP '\d+$')
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "Issue number: $ISSUE_NUMBER"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Add commit identifier template to issue
        id: add-commit-identifier
        if: steps.check-duplicate.outputs.is_duplicate != 'true'
        run: |
          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue_number }}"

          echo "Adding commit identifier template to issue #$ISSUE_NUMBER"

          # Create commit identifier template following project conventions
          # Based on observed patterns: "Implementation of bug-github-issue-{number}-{description}"
          cat > commit_template.md <<EOF

          ## Commit Identifier Template

          When creating a fix commit for this issue, use the following format:

          \`\`\`
          Implementation of bug-github-issue-ISSUE_NUMBER-short-description
          \`\`\`

          **Example for this issue:**
          \`\`\`
          Implementation of bug-github-issue-ISSUE_NUMBER-FAILED_JOB-job-failed
          \`\`\`

          This format ensures:
          - Automatic linking between commits and issues
          - Clear traceability in git history
          - Consistent commit message conventions

          **Replace**:
          - ISSUE_NUMBER with the issue number (ISSUE_NUMBER)
          - short-description with a brief description of the fix (kebab-case)
          EOF

          # Replace placeholders in template
          BRANCH_NAME="${{ inputs.branch_name }}"
          FAILED_JOB="${{ steps.parse-failures.outputs.first_failed_job }}"

          # Convert job name to kebab-case for example
          JOB_NAME_KEBAB=$(echo "$FAILED_JOB" | tr '[:upper:]' '[:lower:]' | sed 's/[[:space:]]\+/-/g')

          # Apply replacements to the template file
          sed -i "s/ISSUE_NUMBER/$ISSUE_NUMBER/g" commit_template.md
          sed -i "s/FAILED_JOB/$JOB_NAME_KEBAB/g" commit_template.md

          # Add the commit identifier template as a comment on the issue
          COMMIT_TEMPLATE_BODY=$(cat commit_template.md)
          gh issue comment $ISSUE_NUMBER \
            --body "$COMMIT_TEMPLATE_BODY" \
            --repo ${{ github.repository }}

          echo "Commit identifier template added to issue #$ISSUE_NUMBER"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Comment on PR with duplicate issue link
        if: inputs.pr_number != '' && steps.check-duplicate.outputs.is_duplicate == 'true'
        run: |
          DUPLICATE_ISSUE_NUM="${{ steps.check-duplicate.outputs.duplicate_issue_number }}"
          DUPLICATE_ISSUE_URL="https://github.com/${{ github.repository }}/issues/$DUPLICATE_ISSUE_NUM"
          COMMENT_BODY="CI/CD workflow failed. This failure is a duplicate of existing issue #$DUPLICATE_ISSUE_NUM: $DUPLICATE_ISSUE_URL"

          echo "Adding comment to PR #${{ inputs.pr_number }}"
          gh pr comment ${{ inputs.pr_number }} \
            --body "$COMMENT_BODY" \
            --repo ${{ github.repository }}
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Comment on PR with new issue link
        if: inputs.pr_number != '' && steps.check-duplicate.outputs.is_duplicate != 'true'
        run: |
          ISSUE_URL="${{ steps.create-issue.outputs.issue_url }}"
          COMMENT_BODY="CI/CD workflow failed. A bug report has been created: $ISSUE_URL"

          echo "Adding comment to PR #${{ inputs.pr_number }}"
          gh pr comment ${{ inputs.pr_number }} \
            --body "$COMMENT_BODY" \
            --repo ${{ github.repository }}
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Call bug resolver for retry failures
        if: steps.check-duplicate.outputs.is_retry == 'true'
        run: |
          RETRY_ISSUE_NUM="${{ steps.check-duplicate.outputs.retry_of_issue }}"
          echo "=========================================="
          echo "Calling Bug Resolver Workflow"
          echo "=========================================="
          echo "Retry detected for issue #$RETRY_ISSUE_NUM"
          echo "Current run status: failure (we are in the bug logger)"
          echo ""
          echo "The bug resolver will be called to update the previous issue labels"
          echo "based on the current failure status."
          echo "=========================================="

      - name: Summary
        run: |
          echo "## Bug Logging Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check-duplicate.outputs.is_duplicate }}" = "true" ]; then
            DUPLICATE_ISSUE_NUM="${{ steps.check-duplicate.outputs.duplicate_issue_number }}"
            DUPLICATE_ISSUE_URL="https://github.com/${{ github.repository }}/issues/$DUPLICATE_ISSUE_NUM"

            echo "### Duplicate Issue Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This failure is a duplicate of existing issue [#$DUPLICATE_ISSUE_NUM]($DUPLICATE_ISSUE_URL)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**No new issue was created.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Duplicate Detection Details" >> $GITHUB_STEP_SUMMARY
            echo "- Feature ID: ${{ steps.extract-info.outputs.feature_id }}" >> $GITHUB_STEP_SUMMARY
            echo "- Job Name: ${{ steps.parse-failures.outputs.first_failed_job }}" >> $GITHUB_STEP_SUMMARY
            echo "- Step Name: ${{ steps.fetch-logs.outputs.failed_step }}" >> $GITHUB_STEP_SUMMARY
            echo "- Log Line Numbers: ${{ steps.fetch-logs.outputs.log_line_numbers }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All fields matched the existing issue, indicating this is the same failure." >> $GITHUB_STEP_SUMMARY
          else
            echo "### New Issue Created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "A GitHub issue has been created for the CI/CD failure:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- Issue: ${{ steps.create-issue.outputs.issue_url }}" >> $GITHUB_STEP_SUMMARY
            echo "- Issue Number: #${{ steps.create-issue.outputs.issue_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- Branch: ${{ inputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- Failed Job: ${{ steps.parse-failures.outputs.first_failed_job }}" >> $GITHUB_STEP_SUMMARY
            echo "- Failed Step: ${{ steps.fetch-logs.outputs.failed_step }}" >> $GITHUB_STEP_SUMMARY
            echo "- Log Lines: ${{ steps.fetch-logs.outputs.log_line_numbers }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Add retry detection information
            if [ "${{ steps.check-duplicate.outputs.is_retry }}" = "true" ]; then
              RETRY_ISSUE_NUM="${{ steps.check-duplicate.outputs.retry_of_issue }}"
              RETRY_ISSUE_URL="https://github.com/${{ github.repository }}/issues/$RETRY_ISSUE_NUM"
              ATTEMPT_COUNT="${{ steps.check-duplicate.outputs.attempt_count }}"

              echo "### Retry Detection" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "This is a **retry attempt** for a previously resolved issue." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "- Previous Issue: [#$RETRY_ISSUE_NUM]($RETRY_ISSUE_URL) (closed)" >> $GITHUB_STEP_SUMMARY
              echo "- Attempt Count: **$ATTEMPT_COUNT**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "A fix was previously attempted and merged, but the CI is still failing." >> $GITHUB_STEP_SUMMARY
              echo "This may indicate the fix was incomplete or a regression occurred." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Automated Action**: The bug resolver workflow will be called to update the status of issue #$RETRY_ISSUE_NUM based on this failure." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            else
              echo "### First Attempt" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "This is the **first occurrence** of this failure (Attempt #${{ steps.check-duplicate.outputs.attempt_count }})" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "### Commit Identifier Template" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "A commit identifier template has been added to the issue as a comment." >> $GITHUB_STEP_SUMMARY
            echo "Developers can use this template to create fix commits that automatically link to the issue." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "${{ steps.check-duplicate.outputs.old_issue_needs_fix_pending }}" = "true" ]; then
              OLD_ISSUE_NUM="${{ steps.check-duplicate.outputs.old_issue_number }}"
              OLD_ISSUE_URL="https://github.com/${{ github.repository }}/issues/$OLD_ISSUE_NUM"
              echo "### Fix Tracking" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Issue [#$OLD_ISSUE_NUM]($OLD_ISSUE_URL) has been marked as \`fix-pending\` because this represents a different failure, suggesting the previous issue may have been resolved." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          if [ -n "${{ inputs.pr_number }}" ]; then
            echo "A comment has been added to PR #${{ inputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Call bug resolver workflow when a retry is detected
  call-bug-resolver:
    name: Update Previous Issue Status
    needs: create-bug-issue
    if: needs.create-bug-issue.outputs.is_retry == 'true'
    uses: ./.github/workflows/bug-resolver.yml
    with:
      current_run_status: 'failure'
      previous_issue_number: ${{ needs.create-bug-issue.outputs.retry_of_issue }}
      action: 'mark_as_resolved'
